
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prime-Phase Vector Visualization Tool - Mathematical Research Explorer</title>
    <style>
        :root {
            --bg-color: #0a0e1a;
            --text-color: #e2e8f0;
            --panel-bg: #1a1f2e;
            --panel-border: #2d3748;
            --accent-color: #4ECDC4;
            --rh-zero: #FFD700;
            --highlight: #667eea;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: var(--bg-color);
            color: var(--text-color);
            line-height: 1.6;
        }

        .header {
            background: linear-gradient(135deg, #1a1f2e 0%, #2d3748 100%);
            border-bottom: 3px solid var(--accent-color);
            padding: 30px 20px;
            text-align: center;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }

        .header h1 {
            font-size: 2.5em;
            color: var(--accent-color);
            margin-bottom: 10px;
            font-weight: 700;
            letter-spacing: -0.5px;
        }

        .header .subtitle {
            font-size: 1.1em;
            color: rgba(255, 255, 255, 0.7);
            margin-bottom: 5px;
        }

        .header .author {
            font-size: 1em;
            color: var(--rh-zero);
            font-weight: 600;
            margin-top: 10px;
        }

        .container {
            display: flex;
            width: 100%;
            max-width: 1600px;
            margin: 0 auto;
            padding: 20px;
            gap: 20px;
        }

        .sidebar {
            width: 320px;
            display: flex;
            flex-direction: column;
            gap: 20px;
            flex-shrink: 0;
        }

        .main-content {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .card {
            background: var(--panel-bg);
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            border: 1px solid var(--panel-border);
        }

        .card h2 {
            color: var(--accent-color);
            margin-bottom: 15px;
            border-bottom: 2px solid var(--accent-color);
            padding-bottom: 8px;
            font-size: 1.4em;
        }

        .card h3 {
            color: var(--rh-zero);
            margin-top: 20px;
            margin-bottom: 12px;
            font-size: 1.1em;
        }

        .slider-group {
            margin-bottom: 20px;
        }

        .slider-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            font-size: 0.95em;
        }

        .slider-group input[type="range"] {
            width: 100%;
            height: 8px;
            -webkit-appearance: none;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            cursor: pointer;
            outline: none;
        }

        .slider-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            background: var(--accent-color);
            border-radius: 50%;
            cursor: pointer;
        }

        .slider-group input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            background: var(--accent-color);
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }

        .slider-note {
            font-size: 0.8em;
            opacity: 0.7;
            margin-top: 5px;
        }

        .key-figure {
            font-size: 1.8em;
            color: var(--rh-zero);
            font-weight: bold;
            margin: 10px 0;
            text-align: center;
            padding: 10px;
            background: rgba(255, 215, 0, 0.1);
            border-radius: 8px;
        }

        .heuristic-box {
            margin-top: 20px;
            padding: 15px;
            border: 1px dashed rgba(255, 215, 0, 0.5);
            border-radius: 8px;
            font-size: 0.9em;
            background: rgba(255, 215, 0, 0.05);
        }

        .canvas-container {
            position: relative;
            background: #000000;
            border-radius: 8px;
            border: 1px solid var(--panel-border);
            padding: 10px;
        }

        #canvas {
            display: block;
            width: 100%;
            height: auto;
            border-radius: 4px;
        }

        .canvas-controls {
            display: flex;
            gap: 10px;
            margin-top: 10px;
            flex-wrap: wrap;
        }

        .canvas-controls input {
            flex: 1;
            min-width: 150px;
            padding: 8px 12px;
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid var(--accent-color);
            color: var(--text-color);
            border-radius: 6px;
            font-size: 0.9em;
        }

        .btn {
            padding: 10px 20px;
            background: var(--accent-color);
            color: #000;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            font-size: 0.95em;
            transition: all 0.2s;
        }

        .btn:hover {
            background: #3db8af;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(78, 205, 196, 0.3);
        }

        .btn-secondary {
            background: var(--highlight);
        }

        .btn-secondary:hover {
            background: #5568d3;
        }

        .export-section {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .stat-box {
            background: rgba(0, 0, 0, 0.3);
            padding: 12px;
            border-radius: 8px;
            border: 1px solid rgba(78, 205, 196, 0.2);
            transition: all 0.2s;
        }

        .stat-box:hover {
            border-color: var(--accent-color);
            background: rgba(78, 205, 196, 0.05);
        }

        .stat-label {
            font-size: 0.85em;
            opacity: 0.8;
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 1.4em;
            color: var(--accent-color);
            font-weight: bold;
        }

        .stat-note {
            font-size: 0.75em;
            opacity: 0.6;
            margin-top: 3px;
            font-style: italic;
        }

        .legend-box {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-top: 15px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .legend-color {
            width: 30px;
            height: 4px;
            border-radius: 2px;
        }

        .vector-status {
            text-align: center;
            margin-top: 10px;
            font-size: 0.9em;
            opacity: 0.9;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 6px;
        }

        .description-text {
            font-size: 0.95em;
            line-height: 1.8;
            margin-bottom: 15px;
        }

        .math-notation {
            font-family: 'Times New Roman', serif;
            font-style: italic;
            font-size: 1.1em;
            color: var(--accent-color);
            text-align: center;
            padding: 15px;
            background: rgba(78, 205, 196, 0.05);
            border-radius: 8px;
            margin: 15px 0;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 10px 0;
        }

        .checkbox-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .checkbox-group label {
            margin: 0;
            cursor: pointer;
            font-weight: normal;
        }

        .param-input {
            width: 100%;
            padding: 8px;
            margin-top: 8px;
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(78, 205, 196, 0.5);
            color: var(--text-color);
            border-radius: 6px;
            font-size: 0.95em;
        }

        .param-input:focus {
            outline: none;
            border-color: var(--accent-color);
            box-shadow: 0 0 8px rgba(78, 205, 196, 0.3);
        }

        .color-input {
            width: 100%;
            height: 40px;
            padding: 5px;
            margin-top: 5px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid var(--accent-color);
            border-radius: 6px;
            cursor: pointer;
        }

        @media (max-width: 1200px) {
            .container {
                flex-direction: column;
            }
            
            .sidebar {
                width: 100%;
            }
        }

        .footer {
            text-align: center;
            padding: 30px;
            color: rgba(255, 255, 255, 0.5);
            font-size: 0.9em;
        }
    </style>
</head>
<body>

<div class="header">
    <h1>Prime-Phase Vector Visualization Tool</h1>
    <div class="subtitle">Mathematical Research Explorer: Riemann Hypothesis & Modular Arithmetic</div>
    <div class="author">by Wessen Getachew</div>
</div>

<div class="container">
    
    <div class="sidebar">
        
        <div class="card">
            <h2>Vector Parameters</h2>

            <div class="slider-group">
                <label>Modulus Ring M: <span id="modulusValue">37</span></label>
                <input type="range" id="modulusSlider" min="5" max="500" step="1" value="37">
                <input type="number" id="modulusInput" min="5" max="10000" value="37" class="param-input">
            </div>

            <div class="slider-group">
                <label>Critical Line Height t: <span id="heightTValue">14.1347</span></label>
                <select id="zeroPreset" class="param-input" style="margin-bottom: 8px;">
                    <option value="">Select Riemann Zero Preset (OEIS A002410)...</option>
                </select>
                <div style="display: flex; gap: 10px; margin-bottom: 8px;">
                    <button id="animateBtn" class="btn" style="flex: 1; padding: 8px;">▶ Animate t</button>
                    <input type="number" id="animSpeed" min="0.1" max="10" step="0.1" value="1" class="param-input" style="width: 80px;" placeholder="Speed">
                </div>
                <input type="range" id="heightTSlider" min="0" max="500" step="0.01" value="14.1347">
                <input type="number" id="heightTInput" min="0" max="10000" step="0.0001" value="14.1347" class="param-input">
                <div class="slider-note">Extended OEIS database: 100 zeros loaded</div>
            </div>

            <h3>OEIS Sequence Presets</h3>
            
            <div class="slider-group">
                <label>Sequence Category:</label>
                <select id="oeisCategory" class="param-input">
                    <option value="">Select OEIS Category...</option>
                    <option value="primes">Prime Number Sequences</option>
                    <option value="highly">Highly Composite Numbers</option>
                    <option value="perfect">Perfect & Abundant Numbers</option>
                    <option value="fibonacci">Fibonacci & Lucas Numbers</option>
                    <option value="factorial">Factorial & Primorial</option>
                    <option value="modular">Modular Arithmetic Sequences</option>
                </select>
            </div>
            
            <div class="slider-group">
                <label>Specific Sequence:</label>
                <select id="oeisSequence" class="param-input">
                    <option value="">Select sequence category first...</option>
                </select>
            </div>
            
            <div class="slider-group">
                <label>Apply Sequence To:</label>
                <select id="oeisTarget" class="param-input">
                    <option value="modulus">Modulus Ring M</option>
                    <option value="cutoff">Prime Cutoff X</option>
                    <option value="both">Both M and X</option>
                </select>
            </div>
            
            <div class="slider-group">
                <label>Sequence Index: <span id="oeisIndexValue">1</span></label>
                <input type="range" id="oeisIndexSlider" min="1" max="50" step="1" value="1">
                <div class="slider-note">Select nth term from sequence</div>
            </div>
            
            <button id="applyOeisBtn" class="btn" style="width: 100%; margin-top: 10px;">Apply OEIS Sequence</button>

            <div class="slider-group">
                <label>Prime Cutoff X: <span id="cutoffXValue">200</span></label>
                <input type="range" id="cutoffXSlider" min="20" max="1000" step="10" value="200">
                <input type="number" id="cutoffXInput" min="20" max="100000" step="10" value="200" class="param-input">
                <div class="slider-note">Maximum prime in summation</div>
            </div>

            <div class="slider-group">
                <label>Phase Multiplier α: <span id="phaseMultValue">1.0000</span></label>
                <input type="range" id="phaseMultSlider" min="0" max="5" step="0.01" value="1.0">
                <input type="number" id="phaseMultInput" min="0" max="100" step="0.01" value="1.0" class="param-input">
                <div class="slider-note">Scales the t-dependent phase</div>
            </div>

            <div class="slider-group">
                <label>Magnitude Exponent β: <span id="magExpValue">0.5000</span></label>
                <input type="range" id="magExpSlider" min="0" max="2" step="0.01" value="0.5">
                <input type="number" id="magExpInput" min="0" max="10" step="0.01" value="0.5" class="param-input">
                <div class="slider-note">Contribution: 1/p^β</div>
            </div>

            <div class="slider-group">
                <label>Modular Weight γ: <span id="modWeightValue">1.0000</span></label>
                <input type="range" id="modWeightSlider" min="0" max="5" step="0.01" value="1.0">
                <input type="number" id="modWeightInput" min="0" max="100" step="0.01" value="1.0" class="param-input">
                <div class="slider-note">Modular phase intensity</div>
            </div>

            <div class="slider-group">
                <label>Start Prime Index: <span id="startIndexValue">0</span></label>
                <input type="range" id="startIndexSlider" min="0" max="100" step="1" value="0">
                <input type="number" id="startIndexInput" min="0" max="10000" step="1" value="0" class="param-input">
                <div class="slider-note">Skip first n primes</div>
            </div>

            <div class="slider-group">
                <label>Sampling Rate: <span id="samplingValue">1</span></label>
                <input type="range" id="samplingSlider" min="1" max="20" step="1" value="1">
                <input type="number" id="samplingInput" min="1" max="100" step="1" value="1" class="param-input">
                <div class="slider-note">Use every nth prime</div>
            </div>
            
            <h3>Vector Magnitude Tracking</h3>
            
            <div class="checkbox-group">
                <input type="checkbox" id="trackHistory" checked>
                <label for="trackHistory">Enable Magnitude History</label>
            </div>
            
            <div class="slider-group">
                <label>History Buffer Size: <span id="historyBufferValue">100</span></label>
                <input type="range" id="historyBufferSlider" min="10" max="500" step="10" value="100">
                <div class="slider-note">Number of data points to track</div>
            </div>
            
            <h3>Current Diagnostic Scores</h3>
            
            <label>Total Vector Magnitude (|P_t|):</label>
            <div class="key-figure" id="magnitudeOutput">--</div>
            
            <label>Coherence Score (C_t):</label>
            <div class="key-figure" id="coherenceOutput">--</div>
            
            <div class="heuristic-box">
                <p><strong>Heuristic Test:</strong> When t approaches a zero (e.g., 14.1347), the summation tends to minimize its magnitude, resulting in a low |P_t| and high C_t (alignment).</p>
            </div>
        </div></option>
                    <option value="98.831194">Zero #29: t ≈ 98.831194</option>
                </select>
                <div style="display: flex; gap: 10px; margin-bottom: 8px;">
                    <button id="animateBtn" class="btn" style="flex: 1; padding: 8px;">▶ Animate t</button>
                    <input type="number" id="animSpeed" min="0.1" max="10" step="0.1" value="1" class="param-input" style="width: 80px;" placeholder="Speed">
                </div>
                <input type="range" id="heightTSlider" min="0" max="100" step="0.01" value="14.1347">
                <input type="number" id="heightTInput" min="0" max="1000" step="0.0001" value="14.1347" class="param-input">
                <div class="slider-note">First 29 non-trivial zeros available in preset</div>
            </div>

            <div class="slider-group">
                <label>Prime Cutoff X: <span id="cutoffXValue">200</span></label>
                <input type="range" id="cutoffXSlider" min="20" max="1000" step="10" value="200">
                <input type="number" id="cutoffXInput" min="20" max="100000" step="10" value="200" class="param-input">
                <div class="slider-note">Maximum prime in summation</div>
            </div>

            <div class="slider-group">
                <label>Phase Multiplier α: <span id="phaseMultValue">1.0000</span></label>
                <input type="range" id="phaseMultSlider" min="0" max="5" step="0.01" value="1.0">
                <input type="number" id="phaseMultInput" min="0" max="100" step="0.01" value="1.0" class="param-input">
                <div class="slider-note">Scales the t-dependent phase</div>
            </div>

            <div class="slider-group">
                <label>Magnitude Exponent β: <span id="magExpValue">0.5000</span></label>
                <input type="range" id="magExpSlider" min="0" max="2" step="0.01" value="0.5">
                <input type="number" id="magExpInput" min="0" max="10" step="0.01" value="0.5" class="param-input">
                <div class="slider-note">Contribution: 1/p^β</div>
            </div>

            <div class="slider-group">
                <label>Modular Weight γ: <span id="modWeightValue">1.0000</span></label>
                <input type="range" id="modWeightSlider" min="0" max="5" step="0.01" value="1.0">
                <input type="number" id="modWeightInput" min="0" max="100" step="0.01" value="1.0" class="param-input">
                <div class="slider-note">Modular phase intensity</div>
            </div>

            <div class="slider-group">
                <label>Start Prime Index: <span id="startIndexValue">0</span></label>
                <input type="range" id="startIndexSlider" min="0" max="100" step="1" value="0">
                <input type="number" id="startIndexInput" min="0" max="10000" step="1" value="0" class="param-input">
                <div class="slider-note">Skip first n primes</div>
            </div>

            <div class="slider-group">
                <label>Sampling Rate: <span id="samplingValue">1</span></label>
                <input type="range" id="samplingSlider" min="1" max="20" step="1" value="1">
                <input type="number" id="samplingInput" min="1" max="100" step="1" value="1" class="param-input">
                <div class="slider-note">Use every nth prime</div>
            </div>
            
            <h3>Current Diagnostic Scores</h3>
            
            <label>Total Vector Magnitude (|P_t|):</label>
            <div class="key-figure" id="magnitudeOutput">--</div>
            
            <label>Coherence Score (C_t):</label>
            <div class="key-figure" id="coherenceOutput">--</div>
            
            <div class="heuristic-box">
                <p><strong>Heuristic Test:</strong> When t approaches a zero (e.g., 14.1347), the summation tends to minimize its magnitude, resulting in a low |P_t| and high C_t (alignment).</p>
            </div>
        </div>

        <div class="card">
            <h2>Visual Customization</h2>

            <div class="slider-group">
                <label>Vector Color:</label>
                <input type="color" id="vectorColor" value="#FFD700" class="color-input">
            </div>

            <div class="slider-group">
                <label>Path Color:</label>
                <input type="color" id="pathColor" value="#FFFFFF" class="color-input">
            </div>

            <div class="slider-group">
                <label>Background Color:</label>
                <input type="color" id="bgColor" value="#000000" class="color-input">
            </div>

            <div class="slider-group">
                <label>Grid/Axes Color:</label>
                <input type="color" id="gridColor" value="#FFFFFF" class="color-input">
            </div>

            <div class="slider-group">
                <label>Vector Line Width: <span id="vectorWidthValue">4</span></label>
                <input type="range" id="vectorWidthSlider" min="1" max="10" step="0.5" value="4">
                <input type="number" id="vectorWidthInput" min="0.5" max="20" step="0.5" value="4" class="param-input">
            </div>

            <div class="slider-group">
                <label>Path Line Width: <span id="pathWidthValue">1.5</span></label>
                <input type="range" id="pathWidthSlider" min="0.5" max="10" step="0.5" value="1.5">
                <input type="number" id="pathWidthInput" min="0.5" max="20" step="0.5" value="1.5" class="param-input">
            </div>

            <div class="slider-group">
                <label>Path Opacity: <span id="pathOpacityValue">15%</span></label>
                <input type="range" id="pathOpacitySlider" min="0" max="100" step="1" value="15">
                <input type="number" id="pathOpacityInput" min="0" max="100" step="1" value="15" class="param-input">
            </div>

            <div class="slider-group">
                <label>Point Size: <span id="pointSizeValue">6</span></label>
                <input type="range" id="pointSizeSlider" min="2" max="20" step="1" value="6">
                <input type="number" id="pointSizeInput" min="1" max="50" step="1" value="6" class="param-input">
            </div>

            <h3>Canvas Labels</h3>

            <div class="slider-group">
                <label>X-Axis Label:</label>
                <input type="text" id="xAxisLabel" value="Real Part" class="param-input">
            </div>

            <div class="slider-group">
                <label>Y-Axis Label:</label>
                <input type="text" id="yAxisLabel" value="Imaginary Part" class="param-input">
            </div>

            <div class="slider-group">
                <label>Label Font Size: <span id="labelSizeValue">14</span></label>
                <input type="range" id="labelSizeSlider" min="8" max="32" step="1" value="14">
                <input type="number" id="labelSizeInput" min="8" max="72" step="1" value="14" class="param-input">
            </div>

            <div class="checkbox-group">
                <input type="checkbox" id="showAxisLabels" checked>
                <label for="showAxisLabels">Show Axis Labels</label>
            </div>

            <div class="checkbox-group">
                <input type="checkbox" id="showScaleMarkers">
                <label for="showScaleMarkers">Show Scale Markers</label>
            </div>
        </div>

    </div>

    <div class="main-content">
        
        <div class="card">
            <h2>Prime-Phase Vector Plot (P_t(M))</h2>
            
            <div class="canvas-controls">
                <input type="text" id="canvasTitle" placeholder="Custom title (optional)" value="Prime-Phase Vector Field">
                <div class="checkbox-group">
                    <input type="checkbox" id="showLegend" checked>
                    <label for="showLegend">Show Legend</label>
                </div>
                <div class="checkbox-group">
                    <input type="checkbox" id="showGrid" checked>
                    <label for="showGrid">Show Grid</label>
                </div>
                <div class="checkbox-group">
                    <input type="checkbox" id="showPath" checked>
                    <label for="showPath">Show Path</label>
                </div>
            </div>
            
            <div class="canvas-container">
                <canvas id="canvas" width="900" height="600"></canvas>
            </div>
            
            <div class="legend-box">
                <div class="legend-item">
                    <div class="legend-color" style="background: #FFD700; height: 3px;"></div>
                    <span>Final Vector P_t(M)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: rgba(255,255,255,0.3);"></div>
                    <span>Summation Path</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: rgba(255,255,255,0.2); height: 1px;"></div>
                    <span>Unit Circle & Axes</span>
                </div>
            </div>
            
            <div class="vector-status" id="vectorStatus">
                Vector End: (0.0000, 0.0000) | Phase: 0.00° | Magnitude: 0.0000
            </div>
            
            <div class="export-section">
                <button class="btn" onclick="exportCanvasPNG()">Export Canvas (PNG)</button>
                <button class="btn btn-secondary" onclick="exportCanvasSVG()">Export Canvas (SVG)</button>
                <button class="btn" onclick="exportDataCSV()">Export Data (CSV)</button>
            </div>
        </div>
        
        <div class="card">
            <h2>Magnitude History Tracking</h2>
            <div class="canvas-container">
                <canvas id="historyCanvas" width="900" height="300"></canvas>
            </div>
            <div class="vector-status" id="historyStatus">
                No history data collected yet. Enable tracking and adjust t parameter.
            </div>
            <div class="export-section">
                <button class="btn" onclick="clearHistory()">Clear History</button>
                <button class="btn btn-secondary" onclick="exportHistoryCSV()">Export History (CSV)</button>
            </div>
        </div>
        
        <div class="card">
            <h2>Statistical Analysis Dashboard</h2>
            
            <h3>Vector Dynamics</h3>
            <div class="stats-grid">
                <div class="stat-box">
                    <div class="stat-label">Prime Count</div>
                    <div class="stat-value" id="primeCount">--</div>
                </div>
                
                <div class="stat-box">
                    <div class="stat-label">Path Length</div>
                    <div class="stat-value" id="pathLength">--</div>
                </div>
                
                <div class="stat-box">
                    <div class="stat-label">Efficiency Ratio</div>
                    <div class="stat-value" id="efficiencyRatio">--</div>
                    <div class="stat-note">|P_t| / PathLength</div>
                </div>
                
                <div class="stat-box">
                    <div class="stat-label">Mean Contribution</div>
                    <div class="stat-value" id="meanContrib">--</div>
                </div>
                
                <div class="stat-box">
                    <div class="stat-label">Std Dev (Real)</div>
                    <div class="stat-value" id="stdReal">--</div>
                </div>
                
                <div class="stat-box">
                    <div class="stat-label">Std Dev (Imag)</div>
                    <div class="stat-value" id="stdImag">--</div>
                </div>
                
                <div class="stat-box">
                    <div class="stat-label">Max Excursion</div>
                    <div class="stat-value" id="maxExcursion">--</div>
                    <div class="stat-note">Furthest from origin</div>
                </div>
                
                <div class="stat-box">
                    <div class="stat-label">Winding Number</div>
                    <div class="stat-value" id="windingNumber">--</div>
                    <div class="stat-note">Net rotations</div>
                </div>
                
                <div class="stat-box">
                    <div class="stat-label">Directional Bias</div>
                    <div class="stat-value" id="directionalBias">--</div>
                    <div class="stat-note">Quadrant preference</div>
                </div>
                
                <div class="stat-box">
                    <div class="stat-label">Cancellation Index</div>
                    <div class="stat-value" id="cancellationIndex">--</div>
                    <div class="stat-note">1 - (|sum| / Σ|terms|)</div>
                </div>
                
                <div class="stat-box">
                    <div class="stat-label">Angular Momentum</div>
                    <div class="stat-value" id="angularMomentum">--</div>
                </div>
                
                <div class="stat-box">
                    <div class="stat-label">Tortuosity</div>
                    <div class="stat-value" id="tortuosity">--</div>
                    <div class="stat-note">PathLength / |P_t|</div>
                </div>
            </div>
            
            <h3>Prime Distribution Metrics</h3>
            <div class="stats-grid">
                <div class="stat-box">
                    <div class="stat-label">Largest Prime</div>
                    <div class="stat-value" id="largestPrime">--</div>
                </div>
                
                <div class="stat-box">
                    <div class="stat-label">Prime Density</div>
                    <div class="stat-value" id="primeDensity">--</div>
                    <div class="stat-note">π(X) / X</div>
                </div>
                
                <div class="stat-box">
                    <div class="stat-label">Li(X) Estimate</div>
                    <div class="stat-value" id="liEstimate">--</div>
                </div>
                
                <div class="stat-box">
                    <div class="stat-label">Estimate Error</div>
                    <div class="stat-value" id="estimateError">--</div>
                    <div class="stat-note">π(X) - Li(X)</div>
                </div>
                
                <div class="stat-box">
                    <div class="stat-label">Avg Prime Gap</div>
                    <div class="stat-value" id="avgGap">--</div>
                </div>
                
                <div class="stat-box">
                    <div class="stat-label">Max Prime Gap</div>
                    <div class="stat-value" id="maxGap">--</div>
                </div>
            </div>
            
            <h3>Modular Structure Analysis</h3>
            <div class="stats-grid">
                <div class="stat-box">
                    <div class="stat-label">φ(M) (Totient)</div>
                    <div class="stat-value" id="totient">--</div>
                </div>
                
                <div class="stat-box">
                    <div class="stat-label">Primitive Roots</div>
                    <div class="stat-value" id="primitiveRoots">--</div>
                </div>
                
                <div class="stat-box">
                    <div class="stat-label">Residue Coverage</div>
                    <div class="stat-value" id="residueCoverage">--</div>
                    <div class="stat-note">Unique p mod M</div>
                </div>
                
                <div class="stat-box">
                    <div class="stat-label">Quadratic Residues</div>
                    <div class="stat-value" id="quadResidues">--</div>
                </div>
                
                <div class="stat-box">
                    <div class="stat-label">M-Periodicity Score</div>
                    <div class="stat-value" id="periodicityScore">--</div>
                </div>
                
                <div class="stat-box">
                    <div class="stat-label">Residue Entropy</div>
                    <div class="stat-value" id="residueEntropy">--</div>
                </div>
            </div>
        </div>
        
        <div class="card">
            <h2>The Prime-Phase Vector Explained</h2>
            
            <p class="description-text">The <strong>Prime-Phase Vector</strong> (P_t(M)) is a conceptual tool linking the discrete structure of the Modular Ring ℤ/Mℤ to the continuous behavior of the Riemann Zeta Function ζ(s).</p>
            
            <h3>1. The Modular Ring Component (M)</h3>
            <p class="description-text">Your visualization involves the <strong>Modulus M</strong> (Ring ℤ/Mℤ). In number theory, the properties of these rings are governed by <strong>Dirichlet Characters (χ)</strong>. The vector's calculation is modulated by a simple M-dependent phase factor, which is analogous to a simplified Dirichlet character, ensuring that the prime's contribution respects the modular arithmetic of the ring.</p>
            
            <h3>2. The Critical Line Component (t)</h3>
            <p class="description-text">The parameter <strong>Height t</strong> sets the imaginary part of the complex number s = 1/2 + it on the <strong>Critical Line</strong>. This is the central location for the search for non-trivial zeros of ζ(s), which are conjectured to govern prime distribution.</p>
            
            <h3>3. The Vector Summation</h3>
            <p class="description-text">The vector P_t(M) is the result of summing complex numbers for every prime p up to the Cutoff X. Each prime contributes a small vector whose phase is dictated by t, and whose magnitude is related to 1/√p.</p>
            
            <div class="math-notation">
                P_t(M) ≈ Σ_{p ≤ X} [Modulation(p, M) / p^(1/2 + it)]
            </div>
            
            <p class="description-text">The sum starts at the origin (center) and accumulates the contribution of each prime, resulting in a random walk-like path (shown in light gray). The final position is the tip of P_t(M) (shown in yellow).</p>
            
            <h3>4. The Coherence Score</h3>
            <p class="description-text">The <strong>Coherence Score (C_t)</strong> reflects the strength of the alignment of the prime vector components. A low final vector magnitude (low |P_t|) relative to the length of the path indicates that the individual prime vectors have largely cancelled each other out, suggesting a high degree of "coherence" or alignment in their complex phases. This cancellation is precisely what happens to an L-function when it is evaluated at a zero.</p>
        </div>
    </div>
    
</div>

<div class="footer">
    Prime-Phase Vector Visualization Tool | Mathematical Research Explorer<br>
    © 2024 Wessen Getachew | Interactive Number Theory Visualization
</div>

<script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const historyCanvas = document.getElementById('historyCanvas');
    const historyCtx = historyCanvas.getContext('2d');
    
    let currentVectorData = null;
    let animationRunning = false;
    let animationFrame = null;
    let magnitudeHistory = [];
    let maxHistorySize = 100;

    // Extended OEIS A002410 - Riemann Zeta zeros (first 100)
    const riemannZeros = [
        14.134725, 21.022040, 25.010858, 30.424876, 32.935062, 37.586178, 40.918719, 43.327073,
        48.005151, 49.773832, 52.970321, 56.446248, 59.347044, 60.831778, 65.112544, 67.079811,
        69.546402, 72.067158, 75.704691, 77.144840, 79.337375, 82.910381, 84.735493, 87.425275,
        88.809111, 92.491899, 94.651344, 95.870634, 98.831194, 101.317851, 103.725538, 105.446623,
        107.168611, 111.029535, 111.874659, 114.320220, 116.226680, 118.790782, 121.370125, 122.946829,
        124.256818, 127.516683, 129.578704, 131.087688, 133.497737, 134.756509, 138.116042, 139.736208,
        141.123707, 143.111845, 146.000982, 147.422765, 150.053751, 150.925257, 153.024693, 156.112909,
        157.597591, 158.849988, 161.188964, 163.030709, 165.537069, 167.184439, 169.094515, 169.911976,
        173.411536, 174.754191, 176.441434, 178.377407, 179.916484, 182.207078, 184.874467, 185.598783,
        187.228922, 189.416188, 192.026656, 193.079726, 195.265396, 196.876481, 198.015309, 201.264490,
        202.493594, 204.189671, 205.394697, 207.906258, 209.576509, 211.691862, 213.347919, 214.547044,
        216.169538, 219.067596, 220.714918, 221.430705, 224.007000, 224.983324, 227.421444, 229.337413,
        231.250188, 231.987235, 233.693027, 236.524229
    ];

    // OEIS Sequences Database
    const oeisSequences = {
        primes: {
            'A000040': { name: 'Prime numbers', terms: [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229] },
            'A001359': { name: 'Lesser of twin primes', terms: [3,5,11,17,29,41,59,71,101,107,137,149,179,191,197,227,239,269,281,311,347,419,431,461,521,569,599,617,641,659,809,821,827,857,881,1019,1031,1049,1061,1091,1151,1229,1277,1289,1301,1319,1427,1451,1481,1487] },
            'A006512': { name: 'Greater of twin primes', terms: [5,7,13,19,31,43,61,73,103,109,139,151,181,193,199,229,241,271,283,313,349,421,433,463,523,571,601,619,643,661,811,823,829,859,883,1021,1033,1051,1063,1093,1153,1231,1279,1291,1303,1321,1429,1453,1483,1489] },
            'A001097': { name: 'Twin primes', terms: [3,5,5,7,11,13,17,19,29,31,41,43,59,61,71,73,101,103,107,109,137,139,149,151,179,181,191,193,197,199,227,229,239,241,269,271,281,283,311,313,347,349,419,421,431,433,461,463,521,523] },
            'A023200': { name: 'Primes p such that p+4 is also prime', terms: [3,7,13,19,37,43,67,79,97,103,109,127,163,193,223,229,277,307,313,349,379,397,439,457,463,487,499,613,643,673,739,757,769,823,853,877,883,907,937,967,997,1009,1033,1039,1087,1093,1153,1213,1279,1297] },
            'A065091': { name: 'Primes of form n^2 + 1', terms: [2,5,17,37,101,197,257,401,577,677,1297,1601,2917,3137,4357,5477,7057,8101,8837,12101,13457,14401,15377,15877,16901,17957,21317,22501,24337,25601,28901,30977,32401,33857,37997,40577,41617,42437,44101,50177,53617,54401,56857,60101,60817,65537,66457,69857] },
        },
        highly: {
            'A002182': { name: 'Highly composite numbers', terms: [1,2,4,6,12,24,36,48,60,120,180,240,360,720,840,1260,1680,2520,5040,7560,10080,15120,20160,25200,27720,45360,50400,55440,83160,110880,166320,221760,277200,332640,498960,554400,665280,720720,1081080,1441440,2162160,2882880,3603600,4324320,6486480,7207200,8648640] },
            'A000005': { name: 'Number of divisors of n', terms: [1,2,2,3,2,4,2,4,3,4,2,6,2,4,4,5,2,6,2,6,4,4,2,8,3,4,4,6,2,8,2,6,4,4,4,9,2,4,4,8,2,8,2,6,6,4,2,10,3,6,4,6,2,8,4,8,4,4,2,12,2,4,6,7,4,8,2,6,4,8,2,12,2,4,6,6,4,8,2,10] },
            'A002110': { name: 'Primorial numbers', terms: [1,2,6,30,210,2310,30030,510510,9699690,223092870,6469693230,200560490130,7420738134810,304250263527210,13082761331670030,614889782588491410] },
            'A051037': { name: 'Number of prime divisors of n!', terms: [0,0,1,2,2,3,3,4,4,4,4,5,5,6,6,6,6,7,7,8,8,8,8,9,9,9,9,9,9,10,10,11,11,11,11,11,11,12,12,12,12,13,13,14,14,14,14,15,15,15,15,15,15,16,16,16,16,16,16,17,17,18,18,18,18,18,18,19,19,19] },
        },
        perfect: {
            'A000396': { name: 'Perfect numbers', terms: [6,28,496,8128,33550336,8589869056,137438691328,2305843008139952128] },
            'A005101': { name: 'Abundant numbers', terms: [12,18,20,24,30,36,40,42,48,54,56,60,66,70,72,78,80,84,88,90,96,100,102,104,108,112,114,120,126,132,138,140,144,150,156,160,162,168,174,176,180,186,192,196,198,200,204,208,210,216] },
            'A005100': { name: 'Deficient numbers', terms: [1,2,3,4,5,7,8,9,10,11,13,14,15,16,17,19,21,22,23,25,26,27,29,31,32,33,34,35,37,38,39,41,43,44,45,46,47,49,50,51,52,53,55,57,58,59,61,62,63,64] },
        },
        fibonacci: {
            'A000045': { name: 'Fibonacci numbers', terms: [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17711,28657,46368,75025,121393,196418,317811,514229,832040,1346269,2178309,3524578,5702887,9227465,14930352,24157817,39088169,63245986] },
            'A000032': { name: 'Lucas numbers', terms: [2,1,3,4,7,11,18,29,47,76,123,199,322,521,843,1364,2207,3571,5778,9349,15127,24476,39603,64079,103682,167761,271443,439204,710647,1149851,1860498,3010349,4870847,7881196,12752043,20633239,33385282,54018521,87403803,141422324] },
            'A001519': { name: 'Fibonacci(2n)', terms: [0,1,3,8,21,55,144,377,987,2584,6765,17711,46368,121393,317811,832040,2178309,5702887,14930352,39088169,102334155,267914296,701408733,1836311903,4807526976,12586269025,32951280099,86267571272,225851433717,591286729879,1548008755920,4052739537881] },
            'A001906': { name: 'Fibonacci(2n+1)', terms: [1,2,5,13,34,89,233,610,1597,4181,10946,28657,75025,196418,514229,1346269,3524578,9227465,24157817,63245986,165580141,433494437,1134903170,2971215073,7778742049,20365011074,53316291173,139583862445,365435296162,956722026041,2504730781961,6557470319842] },
        },
        factorial: {
            'A000142': { name: 'Factorial numbers', terms: [1,1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800,87178291200,1307674368000,20922789888000,355687428096000,6402373705728000,121645100408832000,2432902008176640000] },
            'A002110': { name: 'Primorial numbers', terms: [1,2,6,30,210,2310,30030,510510,9699690,223092870,6469693230,200560490130,7420738134810,304250263527210,13082761331670030,614889782588491410] },
            'A000165': { name: 'Double factorial n!!', terms: [1,1,2,3,8,15,48,105,384,945,3840,10395,46080,135135,645120,2027025,10321920,34459425,185794560,654729075,3715891200,13749310575,81749606400,316234143225,1961990553600,7905853580625,51011754393600,213458046676875] },
        },
        modular: {
            'A000010': { name: 'Euler totient φ(n)', terms: [1,1,2,2,4,2,6,4,6,4,10,4,12,6,8,8,16,6,18,8,12,10,22,8,20,12,18,12,28,8,30,16,20,16,24,12,36,18,24,16,40,12,42,20,24,22,46,16,42,20,32,24,52,18,40,24,36,28,58,16,60,30,36,32,48,20,66,32,44] },
            'A000203': { name: 'Sum of divisors σ(n)', terms: [1,3,4,7,6,12,8,15,13,18,12,28,14,24,24,31,18,39,20,42,32,36,24,60,31,42,40,56,30,72,32,63,48,54,48,91,38,60,56,90,42,96,44,84,78,72,48,124,57,93,72,98,54,120,72,120,80,90,60,168,62,96,104,127,84,144,68,126,96] },
            'A000041': { name: 'Partition numbers', terms: [1,1,2,3,5,7,11,15,22,30,42,56,77,101,135,176,231,297,385,490,627,792,1002,1255,1575,1958,2436,3010,3718,4565,5604,6842,8349,10143,12310,14883,17977,21637,26015,31185,37338,44583,53174,63261,75175,89134,105558,124754,147273,173525] },
            'A001615': { name: 'Jordan function J_2(n)', terms: [1,3,8,12,24,24,48,48,72,72,120,96,168,144,192,192,288,216,360,288,384,360,528,384,600,504,648,576,840,576,960,768,960,864,1152,864,1368,1080,1344,1152,1680,1152,1848,1440,1728,1584,2208,1536,2352,1800,2304,2016,2808,1944,2880,2304] },
        },
    };

    // Populate zero preset dropdown
    function populateZeroPresets() {
        const select = document.getElementById('zeroPreset');
        select.innerHTML = '<option value="">Select Riemann Zero Preset (OEIS A002410)...</option>';
        riemannZeros.forEach((zero, index) => {
            const option = document.createElement('option');
            option.value = zero;
            option.textContent = `Zero #${index + 1}: t ≈ ${zero.toFixed(6)}`;
            select.appendChild(option);
        });
    }

    // OEIS category change handler
    document.getElementById('oeisCategory').addEventListener('change', function() {
        const category = this.value;
        const sequenceSelect = document.getElementById('oeisSequence');
        
        sequenceSelect.innerHTML = '<option value="">Select a sequence...</option>';
        
        if (category && oeisSequences[category]) {
            Object.keys(oeisSequences[category]).forEach(seqId => {
                const seq = oeisSequences[category][seqId];
                const option = document.createElement('option');
                option.value = seqId;
                option.textContent = `${seqId}: ${seq.name}`;
                sequenceSelect.appendChild(option);
            });
        }
    });

    // OEIS index slider
    document.getElementById('oeisIndexSlider').addEventListener('input', function() {
        document.getElementById('oeisIndexValue').textContent = this.value;
    });

    // Apply OEIS sequence
    document.getElementById('applyOeisBtn').addEventListener('click', function() {
        const category = document.getElementById('oeisCategory').value;
        const seqId = document.getElementById('oeisSequence').value;
        const target = document.getElementById('oeisTarget').value;
        const index = parseInt(document.getElementById('oeisIndexSlider').value) - 1;
        
        if (!category || !seqId || !target) {
            alert('Please select category, sequence, and target parameter');
            return;
        }
        
        const sequence = oeisSequences[category][seqId];
        if (!sequence || index >= sequence.terms.length) {
            alert('Invalid sequence or index');
            return;
        }
        
        const value = sequence.terms[index];
        
        if (target === 'modulus' || target === 'both') {
            document.getElementById('modulusSlider').value = value;
            document.getElementById('modulusInput').value = value;
            document.getElementById('modulusValue').textContent = value;
        }
        
        if (target === 'cutoff' || target === 'both') {
            document.getElementById('cutoffXSlider').value = value;
            document.getElementById('cutoffXInput').value = value;
            document.getElementById('cutoffXValue').textContent = value;
        }
        
        updateVisualization();
    });

    // Prime Sieve
    function getPrimes(limit) {
        if (limit < 2) return [];
        const sieve = new Array(limit + 1).fill(true);
        sieve[0] = sieve[1] = false;
        for (let i = 2; i * i <= limit; i++) {
            if (sieve[i]) {
                for (let j = i * i; j <= limit; j += i) {
                    sieve[j] = false;
                }
            }
        }
        const primes = [];
        for (let i = 2; i <= limit; i++) {
            if (sieve[i]) {
                primes.push(i);
            }
        }
        return primes;
    }

    // Euler's Totient Function
    function eulerPhi(n) {
        let result = n;
        let temp = n;
        for (let p = 2; p * p <= temp; p++) {
            if (temp % p === 0) {
                while (temp % p === 0) temp /= p;
                result -= result / p;
            }
        }
        if (temp > 1) result -= result / temp;
        return Math.round(result);
    }

    // Count Primitive Roots
    function countPrimitiveRoots(n) {
        return eulerPhi(eulerPhi(n));
    }

    // Logarithmic Integral Approximation
    function logIntegral(x) {
        if (x <= 1) return 0;
        const gamma = 0.5772156649;
        let sum = gamma + Math.log(Math.log(x));
        let term = 1;
        for (let n = 1; n <= 50; n++) {
            term *= Math.log(x) / n;
            sum += term / n;
            if (Math.abs(term / n) < 1e-10) break;
        }
        return sum;
    }

    // Calculate Prime-Phase Vector with comprehensive statistics
    function calculatePrimePhaseVector(M, t, X, phaseMultiplier, magExponent, modWeight, startIndex, samplingRate) {
        const allPrimes = getPrimes(X);
        
        // Apply start index and sampling rate
        const primes = [];
        for (let i = startIndex; i < allPrimes.length; i += samplingRate) {
            primes.push(allPrimes[i]);
        }
        
        if (primes.length === 0) {
            return getEmptyVectorData(M, t, X);
        }
        
        let totalReal = 0;
        let totalImaginary = 0;
        let totalPathLength = 0;
        let sumOfMagnitudes = 0;
        let path = [{ real: 0, imag: 0 }];
        
        let realContribs = [];
        let imagContribs = [];
        let maxExcursion = 0;
        let windingAngle = 0;
        let lastAngle = 0;
        let residueCounts = new Array(M).fill(0);
        let primeGaps = [];
        
        for (let i = 0; i < primes.length; i++) {
            const p = primes[i];
            const magnitude = 1 / Math.pow(p, magExponent);
            const phase_t = -phaseMultiplier * t * Math.log(p);
            const phase_M = (2 * Math.PI * modWeight * p) / M;
            const combinedPhase = phase_t + phase_M;

            const dReal = magnitude * Math.cos(combinedPhase);
            const dImaginary = magnitude * Math.sin(combinedPhase);
            
            totalReal += dReal;
            totalImaginary += dImaginary;
            
            realContribs.push(dReal);
            imagContribs.push(dImaginary);
            
            const segmentLength = Math.sqrt(dReal * dReal + dImaginary * dImaginary);
            totalPathLength += segmentLength;
            sumOfMagnitudes += magnitude;
            
            path.push({ real: totalReal, imag: totalImaginary });
            
            const currentDist = Math.sqrt(totalReal * totalReal + totalImaginary * totalImaginary);
            maxExcursion = Math.max(maxExcursion, currentDist);
            
            const currentAngle = Math.atan2(totalImaginary, totalReal);
            if (i > 0) {
                let angleDiff = currentAngle - lastAngle;
                while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
                while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
                windingAngle += angleDiff;
            }
            lastAngle = currentAngle;
            
            residueCounts[p % M]++;
            
            if (i > 0) {
                primeGaps.push(p - primes[i - 1]);
            }
        }

        const finalMagnitude = Math.sqrt(totalReal * totalReal + totalImaginary * totalImaginary);
        const coherence = (totalPathLength > 0) ? (1 - (finalMagnitude / totalPathLength)) : 0;
        const cancellationIndex = (sumOfMagnitudes > 0) ? (1 - (finalMagnitude / sumOfMagnitudes)) : 0;
        
        const meanReal = realContribs.reduce((a, b) => a + b, 0) / realContribs.length;
        const meanImag = imagContribs.reduce((a, b) => a + b, 0) / imagContribs.length;
        const stdReal = Math.sqrt(realContribs.reduce((a, b) => a + (b - meanReal) ** 2, 0) / realContribs.length);
        const stdImag = Math.sqrt(imagContribs.reduce((a, b) => a + (b - meanImag) ** 2, 0) / imagContribs.length);
        
        const windingNumber = windingAngle / (2 * Math.PI);
        const angularMomentum = Math.abs(totalReal * totalImaginary);
        
        const quadrantCounts = [0, 0, 0, 0];
        for (let i = 1; i < path.length; i++) {
            const r = path[i].real;
            const im = path[i].imag;
            if (r >= 0 && im >= 0) quadrantCounts[0]++;
            else if (r < 0 && im >= 0) quadrantCounts[1]++;
            else if (r < 0 && im < 0) quadrantCounts[2]++;
            else quadrantCounts[3]++;
        }
        const maxQuadrant = Math.max(...quadrantCounts);
        const directionalBias = maxQuadrant / (path.length - 1);
        
        const nonZeroResidues = residueCounts.filter(c => c > 0).length;
        const residueProbs = residueCounts.map(c => c / primes.length).filter(p => p > 0);
        const residueEntropy = -residueProbs.reduce((sum, p) => sum + p * Math.log2(p), 0);
        
        const avgGap = primeGaps.length > 0 ? primeGaps.reduce((a, b) => a + b, 0) / primeGaps.length : 0;
        const maxGap = primeGaps.length > 0 ? Math.max(...primeGaps) : 0;
        
        const Li_X = (X > 2) ? logIntegral(X) : 0;
        
        return {
            real: totalReal,
            imag: totalImaginary,
            magnitude: finalMagnitude,
            coherence: coherence,
            path: path,
            primes: primes,
            primeCount: primes.length,
            pathLength: totalPathLength,
            cancellationIndex: cancellationIndex,
            stdReal: stdReal,
            stdImag: stdImag,
            maxExcursion: maxExcursion,
            windingNumber: windingNumber,
            angularMomentum: angularMomentum,
            directionalBias: directionalBias,
            largestPrime: primes[primes.length - 1],
            primeDensity: primes.length / X,
            Li_X: Li_X,
            avgGap: avgGap,
            maxGap: maxGap,
            totient: eulerPhi(M),
            primitiveRootCount: countPrimitiveRoots(M),
            residueCoverage: nonZeroResidues,
            residueEntropy: residueEntropy,
            periodicityScore: Math.abs(Math.sin(2 * Math.PI * primes.length / M)),
            M: M,
            t: t,
            X: X
        };
    }

    function getEmptyVectorData(M, t, X) {
        return {
            real: 0,
            imag: 0,
            magnitude: 0,
            coherence: 0,
            path: [{real: 0, imag: 0}],
            primes: [],
            primeCount: 0,
            pathLength: 0,
            cancellationIndex: 0,
            stdReal: 0,
            stdImag: 0,
            maxExcursion: 0,
            windingNumber: 0,
            angularMomentum: 0,
            directionalBias: 0,
            largestPrime: 0,
            primeDensity: 0,
            Li_X: 0,
            avgGap: 0,
            maxGap: 0,
            totient: eulerPhi(M),
            primitiveRootCount: countPrimitiveRoots(M),
            residueCoverage: 0,
            residueEntropy: 0,
            periodicityScore: 0,
            M: M,
            t: t,
            X: X
        };
    }

    // Draw the visualization
    function drawVector(vectorData) {
        const { real, imag, magnitude, coherence, path } = vectorData;
        
        // Update statistics displays
        document.getElementById('magnitudeOutput').textContent = magnitude.toFixed(6);
        document.getElementById('coherenceOutput').textContent = (coherence * 100).toFixed(2) + '%';
        
        document.getElementById('primeCount').textContent = vectorData.primeCount;
        document.getElementById('pathLength').textContent = vectorData.pathLength.toFixed(4);
        document.getElementById('efficiencyRatio').textContent = (magnitude / Math.max(vectorData.pathLength, 0.000001)).toFixed(4);
        document.getElementById('meanContrib').textContent = (magnitude / Math.max(vectorData.primeCount, 1)).toFixed(6);
        document.getElementById('stdReal').textContent = vectorData.stdReal.toFixed(6);
        document.getElementById('stdImag').textContent = vectorData.stdImag.toFixed(6);
        document.getElementById('maxExcursion').textContent = vectorData.maxExcursion.toFixed(4);
        document.getElementById('windingNumber').textContent = vectorData.windingNumber.toFixed(3);
        document.getElementById('directionalBias').textContent = (vectorData.directionalBias * 100).toFixed(1) + '%';
        document.getElementById('cancellationIndex').textContent = (vectorData.cancellationIndex * 100).toFixed(2) + '%';
        document.getElementById('angularMomentum').textContent = vectorData.angularMomentum.toFixed(6);
        document.getElementById('tortuosity').textContent = (vectorData.pathLength / Math.max(magnitude, 0.000001)).toFixed(2);
        
        document.getElementById('largestPrime').textContent = vectorData.largestPrime;
        document.getElementById('primeDensity').textContent = vectorData.primeDensity.toFixed(4);
        document.getElementById('liEstimate').textContent = vectorData.Li_X.toFixed(2);
        document.getElementById('estimateError').textContent = (vectorData.primeCount - vectorData.Li_X).toFixed(2);
        document.getElementById('avgGap').textContent = vectorData.avgGap.toFixed(2);
        document.getElementById('maxGap').textContent = vectorData.maxGap;
        
        document.getElementById('totient').textContent = vectorData.totient;
        document.getElementById('primitiveRoots').textContent = vectorData.primitiveRootCount;
        document.getElementById('residueCoverage').textContent = vectorData.residueCoverage + ' / ' + vectorData.M;
        document.getElementById('quadResidues').textContent = Math.ceil(vectorData.totient / 2);
        document.getElementById('periodicityScore').textContent = vectorData.periodicityScore.toFixed(4);
        document.getElementById('residueEntropy').textContent = vectorData.residueEntropy.toFixed(3);
        
        // Get visual customization values
        const vectorColor = document.getElementById('vectorColor').value;
        const pathColor = document.getElementById('pathColor').value;
        const bgColor = document.getElementById('bgColor').value;
        const gridColor = document.getElementById('gridColor').value;
        const vectorWidth = parseFloat(document.getElementById('vectorWidthSlider').value);
        const pathWidth = parseFloat(document.getElementById('pathWidthSlider').value);
        const pathOpacity = parseInt(document.getElementById('pathOpacitySlider').value) / 100;
        const pointSize = parseFloat(document.getElementById('pointSizeSlider').value);
        const labelSize = parseInt(document.getElementById('labelSizeSlider').value);
        const xAxisLabel = document.getElementById('xAxisLabel').value;
        const yAxisLabel = document.getElementById('yAxisLabel').value;
        const showAxisLabels = document.getElementById('showAxisLabels').checked;
        const showScaleMarkers = document.getElementById('showScaleMarkers').checked;
        
        // Canvas drawing
        const W = canvas.width;
        const H = canvas.height;
        const centerX = W / 2;
        const centerY = H / 2;
        ctx.clearRect(0, 0, W, H);
        
        // Fill background
        ctx.fillStyle = bgColor;
        ctx.fillRect(0, 0, W, H);

        // Determine scale
        let maxDim = 0;
        for (const point of path) {
            maxDim = Math.max(maxDim, Math.abs(point.real), Math.abs(point.imag));
        }
        const scaleFactor = Math.min(W, H) / (2.4 * Math.max(maxDim, 0.5));

        // Draw grid if enabled
        if (document.getElementById('showGrid').checked) {
            ctx.strokeStyle = hexToRGBA(gridColor, 0.1);
            ctx.lineWidth = 1;
            
            // Vertical lines
            for (let i = -10; i <= 10; i++) {
                const x = centerX + i * scaleFactor * 0.5;
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, H);
                ctx.stroke();
            }
            
            // Horizontal lines
            for (let i = -10; i <= 10; i++) {
                const y = centerY + i * scaleFactor * 0.5;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(W, y);
                ctx.stroke();
            }
        }

        // Draw unit circle and axes
        ctx.beginPath();
        ctx.strokeStyle = hexToRGBA(gridColor, 0.25);
        ctx.lineWidth = 2;
        ctx.arc(centerX, centerY, scaleFactor, 0, 2 * Math.PI);
        ctx.stroke();
        
        ctx.beginPath();
        ctx.strokeStyle = hexToRGBA(gridColor, 0.3);
        ctx.lineWidth = 2;
        ctx.moveTo(0, centerY);
        ctx.lineTo(W, centerY);
        ctx.moveTo(centerX, 0);
        ctx.lineTo(centerX, H);
        ctx.stroke();
        
        // Scale markers
        if (showScaleMarkers) {
            ctx.fillStyle = hexToRGBA(gridColor, 0.5);
            ctx.font = `${labelSize - 2}px Segoe UI`;
            ctx.textAlign = 'center';
            
            const scaleUnit = maxDim / 2;
            for (let i = -2; i <= 2; i++) {
                if (i !== 0) {
                    const val = (i * scaleUnit / 2).toFixed(2);
                    ctx.fillText(val, centerX + i * scaleFactor / 2, centerY + 20);
                    ctx.fillText(val, centerX - 25, centerY - i * scaleFactor / 2);
                }
            }
        }
        
        // Axis labels
        if (showAxisLabels) {
            ctx.fillStyle = hexToRGBA(gridColor, 0.7);
            ctx.font = `${labelSize}px Segoe UI`;
            ctx.textAlign = 'right';
            ctx.fillText(xAxisLabel, W - 10, centerY - 10);
            ctx.textAlign = 'left';
            ctx.fillText(yAxisLabel, centerX + 10, 20);
        }
        
        // Draw the path if enabled
        if (document.getElementById('showPath').checked) {
            ctx.beginPath();
            ctx.strokeStyle = hexToRGBA(pathColor, pathOpacity);
            ctx.lineWidth = pathWidth;
            ctx.moveTo(centerX, centerY);
            for (let i = 1; i < path.length; i++) {
                ctx.lineTo(centerX + path[i].real * scaleFactor, centerY - path[i].imag * scaleFactor);
            }
            ctx.stroke();
        }

        // Draw the final vector P_t(M)
        ctx.beginPath();
        ctx.strokeStyle = vectorColor;
        ctx.lineWidth = vectorWidth;
        ctx.moveTo(centerX, centerY);
        ctx.lineTo(centerX + real * scaleFactor, centerY - imag * scaleFactor);
        ctx.stroke();
        
        // Draw arrowhead
        const angle = Math.atan2(-imag, real);
        const arrowLength = 15;
        const arrowAngle = Math.PI / 6;
        const endX = centerX + real * scaleFactor;
        const endY = centerY - imag * scaleFactor;
        
        ctx.beginPath();
        ctx.fillStyle = vectorColor;
        ctx.moveTo(endX, endY);
        ctx.lineTo(
            endX - arrowLength * Math.cos(angle - arrowAngle),
            endY + arrowLength * Math.sin(angle - arrowAngle)
        );
        ctx.lineTo(
            endX - arrowLength * Math.cos(angle + arrowAngle),
            endY + arrowLength * Math.sin(angle + arrowAngle)
        );
        ctx.closePath();
        ctx.fill();
        
        // Draw the final point
        ctx.beginPath();
        ctx.fillStyle = vectorColor;
        ctx.arc(endX, endY, pointSize, 0, 2 * Math.PI);
        ctx.fill();
        
        // Draw title if enabled
        const customTitle = document.getElementById('canvasTitle').value;
        if (customTitle) {
            ctx.fillStyle = 'rgba(78, 205, 196, 1)';
            ctx.font = 'bold 18px Segoe UI';
            ctx.textAlign = 'center';
            ctx.fillText(customTitle, W / 2, 25);
        }

        // Update status
        const phaseAngle = Math.atan2(imag, real) * 180 / Math.PI;
        document.getElementById('vectorStatus').textContent = 
            `Vector End: (${real.toFixed(4)}, ${imag.toFixed(4)}) | Phase: ${phaseAngle.toFixed(2)}° | Magnitude: ${magnitude.toFixed(6)}`;
    }

    // Helper function to convert hex to RGBA
    function hexToRGBA(hex, alpha) {
        const r = parseInt(hex.slice(1, 3), 16);
        const g = parseInt(hex.slice(3, 5), 16);
        const b = parseInt(hex.slice(5, 7), 16);
        return `rgba(${r}, ${g}, ${b}, ${alpha})`;
    }

    // Update visualization
    function updateVisualization() {
        const M = parseInt(document.getElementById('modulusSlider').value);
        const t = parseFloat(document.getElementById('heightTSlider').value);
        const X = parseInt(document.getElementById('cutoffXSlider').value);
        const phaseMultiplier = parseFloat(document.getElementById('phaseMultSlider').value);
        const magExponent = parseFloat(document.getElementById('magExpSlider').value);
        const modWeight = parseFloat(document.getElementById('modWeightSlider').value);
        const startIndex = parseInt(document.getElementById('startIndexSlider').value);
        const samplingRate = parseInt(document.getElementById('samplingSlider').value);

        document.getElementById('modulusValue').textContent = M;
        document.getElementById('heightTValue').textContent = t.toFixed(4);
        document.getElementById('cutoffXValue').textContent = X;
        document.getElementById('phaseMultValue').textContent = phaseMultiplier.toFixed(4);
        document.getElementById('magExpValue').textContent = magExponent.toFixed(4);
        document.getElementById('modWeightValue').textContent = modWeight.toFixed(4);
        document.getElementById('startIndexValue').textContent = startIndex;
        document.getElementById('samplingValue').textContent = samplingRate;

        currentVectorData = calculatePrimePhaseVector(M, t, X, phaseMultiplier, magExponent, modWeight, startIndex, samplingRate);
        drawVector(currentVectorData);
        
        // Track history if enabled
        if (document.getElementById('trackHistory').checked) {
            magnitudeHistory.push({
                t: t,
                magnitude: currentVectorData.magnitude,
                coherence: currentVectorData.coherence
            });
            
            // Trim history to max size
            if (magnitudeHistory.length > maxHistorySize) {
                magnitudeHistory.shift();
            }
            
            drawHistoryChart();
        }
    }

    // Synchronize sliders and inputs
    function syncSliderToInput(sliderId, inputId, valueId, decimals = 0) {
        const slider = document.getElementById(sliderId);
        const input = document.getElementById(inputId);
        const valueSpan = document.getElementById(valueId);
        
        slider.addEventListener('input', () => {
            const val = decimals > 0 ? parseFloat(slider.value).toFixed(decimals) : parseInt(slider.value);
            input.value = val;
            if (valueSpan) valueSpan.textContent = val;
            updateVisualization();
        });
        
        input.addEventListener('input', () => {
            const val = decimals > 0 ? parseFloat(input.value) : parseInt(input.value);
            if (!isNaN(val)) {
                slider.value = val;
                if (valueSpan) valueSpan.textContent = decimals > 0 ? val.toFixed(decimals) : val;
                updateVisualization();
            }
        });
    }

    // Event listeners for visual customization
    function setupVisualListeners() {
        document.getElementById('vectorColor').addEventListener('input', updateVisualization);
        document.getElementById('pathColor').addEventListener('input', updateVisualization);
        document.getElementById('bgColor').addEventListener('input', updateVisualization);
        document.getElementById('gridColor').addEventListener('input', updateVisualization);
        
        syncSliderToInput('vectorWidthSlider', 'vectorWidthInput', 'vectorWidthValue', 1);
        syncSliderToInput('pathWidthSlider', 'pathWidthInput', 'pathWidthValue', 1);
        syncSliderToInput('pathOpacitySlider', 'pathOpacityInput', 'pathOpacityValue', 0);
        syncSliderToInput('pointSizeSlider', 'pointSizeInput', 'pointSizeValue', 0);
        syncSliderToInput('labelSizeSlider', 'labelSizeInput', 'labelSizeValue', 0);
        
        document.getElementById('xAxisLabel').addEventListener('input', updateVisualization);
        document.getElementById('yAxisLabel').addEventListener('input', updateVisualization);
        document.getElementById('showAxisLabels').addEventListener('change', updateVisualization);
        document.getElementById('showScaleMarkers').addEventListener('change', updateVisualization);
        
        // Update path opacity display to show percentage
        document.getElementById('pathOpacitySlider').addEventListener('input', () => {
            const val = document.getElementById('pathOpacitySlider').value;
            document.getElementById('pathOpacityValue').textContent = val + '%';
        });
        document.getElementById('pathOpacityInput').addEventListener('input', () => {
            const val = document.getElementById('pathOpacityInput').value;
            document.getElementById('pathOpacityValue').textContent = val + '%';
        });
    }

    // Export functions
    function exportCanvasPNG() {
        const link = document.createElement('a');
        link.download = `prime_phase_vector_M${currentVectorData.M}_t${currentVectorData.t.toFixed(4)}_X${currentVectorData.X}.png`;
        link.href = canvas.toDataURL('image/png');
        link.click();
    }

    function exportCanvasSVG() {
        // Create SVG representation
        const W = canvas.width;
        const H = canvas.height;
        const { real, imag, path } = currentVectorData;
        
        const centerX = W / 2;
        const centerY = H / 2;
        
        let maxDim = 0;
        for (const point of path) {
            maxDim = Math.max(maxDim, Math.abs(point.real), Math.abs(point.imag));
        }
        const scaleFactor = Math.min(W, H) / (2.4 * Math.max(maxDim, 0.5));
        
        let svg = `<svg width="${W}" height="${H}" xmlns="http://www.w3.org/2000/svg">`;
        svg += `<rect width="${W}" height="${H}" fill="#000000"/>`;
        
        // Unit circle
        svg += `<circle cx="${centerX}" cy="${centerY}" r="${scaleFactor}" stroke="rgba(255,255,255,0.25)" stroke-width="2" fill="none"/>`;
        
        // Axes
        svg += `<line x1="0" y1="${centerY}" x2="${W}" y2="${centerY}" stroke="rgba(255,255,255,0.3)" stroke-width="2"/>`;
        svg += `<line x1="${centerX}" y1="0" x2="${centerX}" y2="${H}" stroke="rgba(255,255,255,0.3)" stroke-width="2"/>`;
        
        // Path
        if (document.getElementById('showPath').checked) {
            svg += `<polyline points="${centerX},${centerY}`;
            for (let i = 1; i < path.length; i++) {
                svg += ` ${centerX + path[i].real * scaleFactor},${centerY - path[i].imag * scaleFactor}`;
            }
            svg += `" stroke="rgba(255,255,255,0.15)" stroke-width="1.5" fill="none"/>`;
        }
        
        // Final vector
        const endX = centerX + real * scaleFactor;
        const endY = centerY - imag * scaleFactor;
        svg += `<line x1="${centerX}" y1="${centerY}" x2="${endX}" y2="${endY}" stroke="#FFD700" stroke-width="4"/>`;
        svg += `<circle cx="${endX}" cy="${endY}" r="6" fill="#FFD700"/>`;
        
        svg += '</svg>';
        
        const blob = new Blob([svg], { type: 'image/svg+xml' });
        const link = document.createElement('a');
        link.download = `prime_phase_vector_M${currentVectorData.M}_t${currentVectorData.t.toFixed(4)}_X${currentVectorData.X}.svg`;
        link.href = URL.createObjectURL(blob);
        link.click();
    }

    function exportDataCSV() {
        if (!currentVectorData) return;
        
        let csv = 'Prime-Phase Vector Data Export\n';
        csv += `Parameters: M=${currentVectorData.M}, t=${currentVectorData.t}, X=${currentVectorData.X}\n\n`;
        
        csv += 'Summary Statistics\n';
        csv += 'Metric,Value\n';
        csv += `Vector Magnitude,${currentVectorData.magnitude}\n`;
        csv += `Coherence Score,${currentVectorData.coherence}\n`;
        csv += `Prime Count,${currentVectorData.primeCount}\n`;
        csv += `Path Length,${currentVectorData.pathLength}\n`;
        csv += `Cancellation Index,${currentVectorData.cancellationIndex}\n`;
        csv += `Max Excursion,${currentVectorData.maxExcursion}\n`;
        csv += `Winding Number,${currentVectorData.windingNumber}\n`;
        csv += `Angular Momentum,${currentVectorData.angularMomentum}\n`;
        csv += `Std Dev (Real),${currentVectorData.stdReal}\n`;
        csv += `Std Dev (Imag),${currentVectorData.stdImag}\n`;
        csv += `Largest Prime,${currentVectorData.largestPrime}\n`;
        csv += `Prime Density,${currentVectorData.primeDensity}\n`;
        csv += `Li(X) Estimate,${currentVectorData.Li_X}\n`;
        csv += `Avg Prime Gap,${currentVectorData.avgGap}\n`;
        csv += `Max Prime Gap,${currentVectorData.maxGap}\n`;
        csv += `Euler Totient,${currentVectorData.totient}\n`;
        csv += `Primitive Roots,${currentVectorData.primitiveRootCount}\n`;
        csv += `Residue Coverage,${currentVectorData.residueCoverage}\n`;
        csv += `Residue Entropy,${currentVectorData.residueEntropy}\n`;
        csv += `Periodicity Score,${currentVectorData.periodicityScore}\n\n`;
        
        csv += 'Prime List\n';
        csv += 'Index,Prime\n';
        currentVectorData.primes.forEach((p, i) => {
            csv += `${i + 1},${p}\n`;
        });
        
        csv += '\nVector Path Data\n';
        csv += 'Step,Real,Imaginary,Distance from Origin\n';
        currentVectorData.path.forEach((point, i) => {
            const dist = Math.sqrt(point.real * point.real + point.imag * point.imag);
            csv += `${i},${point.real},${point.imag},${dist}\n`;
        });
        
        const blob = new Blob([csv], { type: 'text/csv' });
        const link = document.createElement('a');
        link.download = `prime_phase_data_M${currentVectorData.M}_t${currentVectorData.t.toFixed(4)}_X${currentVectorData.X}.csv`;
        link.href = URL.createObjectURL(blob);
        link.click();
    }

    // Draw history chart
    function drawHistoryChart() {
        const W = historyCanvas.width;
        const H = historyCanvas.height;
        const padding = 50;
        
        historyCtx.clearRect(0, 0, W, H);
        historyCtx.fillStyle = '#000000';
        historyCtx.fillRect(0, 0, W, H);
        
        if (magnitudeHistory.length < 2) {
            historyCtx.fillStyle = 'rgba(255, 255, 255, 0.5)';
            historyCtx.font = '14px Segoe UI';
            historyCtx.textAlign = 'center';
            historyCtx.fillText('Collecting data...', W / 2, H / 2);
            return;
        }
        
        // Find ranges
        const tValues = magnitudeHistory.map(h => h.t);
        const magValues = magnitudeHistory.map(h => h.magnitude);
        const minT = Math.min(...tValues);
        const maxT = Math.max(...tValues);
        const minMag = Math.min(...magValues);
        const maxMag = Math.max(...magValues);
        
        const rangeT = maxT - minT || 1;
        const rangeMag = maxMag - minMag || 1;
        
        // Draw axes
        historyCtx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
        historyCtx.lineWidth = 2;
        historyCtx.beginPath();
        historyCtx.moveTo(padding, padding);
        historyCtx.lineTo(padding, H - padding);
        historyCtx.lineTo(W - padding, H - padding);
        historyCtx.stroke();
        
        // Draw grid
        historyCtx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
        historyCtx.lineWidth = 1;
        for (let i = 0; i <= 5; i++) {
            const y = padding + (H - 2 * padding) * i / 5;
            historyCtx.beginPath();
            historyCtx.moveTo(padding, y);
            historyCtx.lineTo(W - padding, y);
            historyCtx.stroke();
        }
        
        // Draw labels
        historyCtx.fillStyle = 'rgba(255, 255, 255, 0.7)';
        historyCtx.font = '12px Segoe UI';
        historyCtx.textAlign = 'center';
        historyCtx.fillText('t (Critical Line Height)', W / 2, H - 10);
        
        historyCtx.save();
        historyCtx.translate(15, H / 2);
        historyCtx.rotate(-Math.PI / 2);
        historyCtx.fillText('|P_t| Magnitude', 0, 0);
        historyCtx.restore();
        
        // Draw magnitude line
        historyCtx.strokeStyle = '#FFD700';
        historyCtx.lineWidth = 2;
        historyCtx.beginPath();
        
        for (let i = 0; i < magnitudeHistory.length; i++) {
            const h = magnitudeHistory[i];
            const x = padding + ((h.t - minT) / rangeT) * (W - 2 * padding);
            const y = H - padding - ((h.magnitude - minMag) / rangeMag) * (H - 2 * padding);
            
            if (i === 0) {
                historyCtx.moveTo(x, y);
            } else {
                historyCtx.lineTo(x, y);
            }
        }
        historyCtx.stroke();
        
        // Draw points
        historyCtx.fillStyle = '#FFD700';
        for (let i = 0; i < magnitudeHistory.length; i++) {
            const h = magnitudeHistory[i];
            const x = padding + ((h.t - minT) / rangeT) * (W - 2 * padding);
            const y = H - padding - ((h.magnitude - minMag) / rangeMag) * (H - 2 * padding);
            
            historyCtx.beginPath();
            historyCtx.arc(x, y, 3, 0, 2 * Math.PI);
            historyCtx.fill();
        }
        
        // Update status
        const avgMag = magValues.reduce((a, b) => a + b, 0) / magValues.length;
        const minMagValue = Math.min(...magValues);
        const minMagT = tValues[magValues.indexOf(minMagValue)];
        
        document.getElementById('historyStatus').textContent = 
            `Data Points: ${magnitudeHistory.length} | Avg Magnitude: ${avgMag.toFixed(6)} | Min at t = ${minMagT.toFixed(4)} (|P_t| = ${minMagValue.toFixed(6)})`;
    }

    // Clear history
    function clearHistory() {
        magnitudeHistory = [];
        drawHistoryChart();
        document.getElementById('historyStatus').textContent = 
            'History cleared. Enable tracking and adjust t parameter.';
    }

    // Export history
    function exportHistoryCSV() {
        if (magnitudeHistory.length === 0) {
            alert('No history data to export');
            return;
        }
        
        let csv = 'Magnitude History Export\n';
        csv += 't,Magnitude,Coherence\n';
        magnitudeHistory.forEach(h => {
            csv += `${h.t},${h.magnitude},${h.coherence}\n`;
        });
        
        const blob = new Blob([csv], { type: 'text/csv' });
        const link = document.createElement('a');
        link.download = 'magnitude_history.csv';
        link.href = URL.createObjectURL(blob);
        link.click();
    }

    // Animation control
    function toggleAnimation() {
        const btn = document.getElementById('animateBtn');
        const slider = document.getElementById('heightTSlider');
        const speed = parseFloat(document.getElementById('animSpeed').value) || 1;
        
        if (!animationRunning) {
            // Start animation
            animationRunning = true;
            btn.textContent = '⏸ Pause';
            btn.style.background = '#667eea';
            
            function animate() {
                if (!animationRunning) return;
                
                let currentValue = parseFloat(slider.value);
                const maxValue = parseFloat(slider.max);
                
                // Increment based on speed (0.01 is base increment per frame at 60fps)
                currentValue += 0.01 * speed;
                
                // Loop back to beginning if we reach the end
                if (currentValue > maxValue) {
                    currentValue = parseFloat(slider.min);
                }
                
                slider.value = currentValue;
                document.getElementById('heightTInput').value = currentValue.toFixed(4);
                document.getElementById('heightTValue').textContent = currentValue.toFixed(6);
                
                updateVisualization();
                
                animationFrame = requestAnimationFrame(animate);
            }
            
            animate();
        } else {
            // Stop animation
            animationRunning = false;
            btn.textContent = '▶ Animate t';
            btn.style.background = '';
            if (animationFrame) {
                cancelAnimationFrame(animationFrame);
            }
        }
    }

    document.getElementById('animateBtn').addEventListener('click', toggleAnimation);

    // Zero preset selector
    document.getElementById('zeroPreset').addEventListener('change', function() {
        const value = this.value;
        if (value) {
            const tValue = parseFloat(value);
            document.getElementById('heightTSlider').value = tValue;
            document.getElementById('heightTInput').value = tValue;
            document.getElementById('heightTValue').textContent = tValue.toFixed(6);
            updateVisualization();
        }
    });

    // Event listeners
    document.getElementById('showLegend').addEventListener('change', updateVisualization);
    document.getElementById('showGrid').addEventListener('change', updateVisualization);
    document.getElementById('showPath').addEventListener('change', updateVisualization);
    document.getElementById('canvasTitle').addEventListener('input', updateVisualization);

    // Initialize
    function init() {
        // Populate zero presets
        populateZeroPresets();
        
        // Setup synchronization for all parameter controls
        syncSliderToInput('modulusSlider', 'modulusInput', 'modulusValue', 0);
        syncSliderToInput('heightTSlider', 'heightTInput', 'heightTValue', 4);
        syncSliderToInput('cutoffXSlider', 'cutoffXInput', 'cutoffXValue', 0);
        syncSliderToInput('phaseMultSlider', 'phaseMultInput', 'phaseMultValue', 4);
        syncSliderToInput('magExpSlider', 'magExpInput', 'magExpValue', 4);
        syncSliderToInput('modWeightSlider', 'modWeightInput', 'modWeightValue', 4);
        syncSliderToInput('startIndexSlider', 'startIndexInput', 'startIndexValue', 0);
        syncSliderToInput('samplingSlider', 'samplingInput', 'samplingValue', 0);
        
        // History buffer size
        document.getElementById('historyBufferSlider').addEventListener('input', function() {
            maxHistorySize = parseInt(this.value);
            document.getElementById('historyBufferValue').textContent = maxHistorySize;
            // Trim if needed
            while (magnitudeHistory.length > maxHistorySize) {
                magnitudeHistory.shift();
            }
            drawHistoryChart();
        });
        
        setupVisualListeners();
        updateVisualization();
        drawHistoryChart();
    }

    init();
</script>

</body>
    </html>
