

<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prime-Phase Vector Visualization Tool - Mathematical Research Explorer</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Segoe UI', system-ui, sans-serif; background: #0a0a0f; color: #e0e0e0; }
        
        .tab-navigation { background: #12121a; border-bottom: 2px solid #2a2a4a; display: flex; justify-content: center; padding: 0 40px; }
        .tab-btn { background: transparent; border: none; color: #888; padding: 16px 32px; font-size: 0.95rem; font-weight: 600; cursor: pointer; border-bottom: 3px solid transparent; transition: all 0.3s; }
        .tab-btn:hover { color: #ffd700; background: rgba(255, 215, 0, 0.05); }
        .tab-btn.active { color: #ffd700; border-bottom-color: #ffd700; }
        
        .tab-content { display: none; }
        .tab-content.active { display: block; }
        
        .header { background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); padding: 32px 40px; border-bottom: 1px solid #2a2a4a; }
        .header h1 { font-size: 2rem; color: #ffd700; margin-bottom: 8px; letter-spacing: -0.5px; }
        .header .subtitle { color: #aaa; font-size: 1rem; margin-bottom: 12px; }
        .header .author { color: #888; font-size: 0.9rem; margin-top: 4px; }
        
        .documentation { max-width: 1400px; margin: 0 auto; padding: 32px 40px; }
        .doc-section { background: #12121a; border-radius: 8px; border: 1px solid #2a2a4a; padding: 24px; margin-bottom: 24px; }
        .doc-section h2 { color: #ffd700; font-size: 1.4rem; margin-bottom: 16px; border-bottom: 2px solid #2a2a4a; padding-bottom: 8px; }
        .doc-section h3 { color: #ffd700; font-size: 1.1rem; margin: 20px 0 12px 0; }
        .doc-section p { line-height: 1.7; margin-bottom: 12px; color: #ccc; }
        .doc-section ul { margin-left: 24px; line-height: 1.8; color: #ccc; }
        .doc-section li { margin-bottom: 8px; }
        .doc-section a { color: #ffd700; text-decoration: none; transition: opacity 0.2s; }
        .doc-section a:hover { opacity: 0.7; text-decoration: underline; }
        
        .formula-block { background: #1a1a2a; padding: 16px; border-radius: 6px; font-family: 'Times New Roman', serif; font-size: 1.2rem; text-align: center; color: #ffd700; margin: 16px 0; border-left: 4px solid #ffd700; }
        
        .main-container { display: grid; grid-template-columns: 360px 1fr 360px; gap: 20px; padding: 20px; max-width: 2000px; margin: 0 auto; }
        
        @media (max-width: 1400px) {
            .main-container { grid-template-columns: 1fr; }
            .documentation { padding: 24px 20px; }
            .canvas-wrapper canvas { max-width: 100%; height: auto; }
        }
        
        .panel { background: #12121a; border-radius: 8px; border: 1px solid #2a2a4a; }
        .panel-header { padding: 14px 16px; border-bottom: 1px solid #2a2a4a; font-weight: 600; color: #ffd700; font-size: 0.9rem; display: flex; justify-content: space-between; align-items: center; }
        .panel-content { padding: 16px; }
        
        .control-group { margin-bottom: 16px; }
        .control-group:last-child { margin-bottom: 0; }
        .control-label { display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px; font-size: 0.8rem; color: #aaa; }
        .control-value { color: #ffd700; font-family: monospace; }
        
        input[type="range"] { width: 100%; height: 6px; border-radius: 3px; background: #2a2a4a; outline: none; -webkit-appearance: none; }
        input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; width: 14px; height: 14px; border-radius: 50%; background: #ffd700; cursor: pointer; }
        input[type="range"]::-moz-range-thumb { width: 14px; height: 14px; border-radius: 50%; background: #ffd700; cursor: pointer; border: none; }
        
        input[type="number"], select, input[type="text"] { width: 100%; padding: 8px 10px; background: #1a1a2a; border: 1px solid #3a3a5a; border-radius: 4px; color: #e0e0e0; font-size: 0.85rem; }
        input[type="number"]:focus, select:focus, input[type="text"]:focus { outline: none; border-color: #ffd700; }
        
        input[type="color"] { width: 100%; height: 36px; border: 1px solid #3a3a5a; border-radius: 4px; cursor: pointer; background: #1a1a2a; }
        
        .btn { padding: 10px 16px; background: linear-gradient(135deg, #ffd700 0%, #ffaa00 100%); border: none; border-radius: 4px; color: #000; font-weight: 600; cursor: pointer; font-size: 0.85rem; transition: all 0.2s; width: 100%; }
        .btn:hover { transform: translateY(-1px); box-shadow: 0 4px 12px rgba(255, 215, 0, 0.3); }
        .btn:active { transform: translateY(0); }
        .btn-secondary { background: #2a2a4a; color: #e0e0e0; }
        .btn-secondary:hover { background: #3a3a5a; box-shadow: none; }
        
        .canvas-container { position: relative; background: #000; border-radius: 8px; overflow: hidden; }
        .canvas-wrapper { position: relative; overflow: hidden; }
        canvas { display: block; cursor: grab; }
        canvas:active { cursor: grabbing; }
        
        .canvas-overlay { position: absolute; top: 10px; right: 10px; display: flex; gap: 8px; z-index: 10; }
        .overlay-btn { background: rgba(0, 0, 0, 0.7); border: 1px solid #3a3a5a; color: #ffd700; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 0.75rem; transition: all 0.2s; }
        .overlay-btn:hover { background: rgba(255, 215, 0, 0.2); border-color: #ffd700; }
        .stats-grid { display: grid; gap: 10px; }
        .stat-item { background: #1a1a2a; padding: 10px 12px; border-radius: 4px; border-left: 3px solid #ffd700; }
        .stat-label { font-size: 0.7rem; color: #888; text-transform: uppercase; letter-spacing: 0.5px; }
        .stat-value { font-size: 1.1rem; color: #ffd700; font-family: monospace; margin-top: 2px; }
        
        .toggle-row { display: flex; align-items: center; justify-content: space-between; padding: 8px 0; }
        .toggle-row label { font-size: 0.85rem; color: #ccc; }
        .toggle { position: relative; width: 40px; height: 22px; }
        .toggle input { opacity: 0; width: 0; height: 0; }
        .toggle-slider { position: absolute; inset: 0; background: #2a2a4a; border-radius: 11px; cursor: pointer; transition: 0.2s; }
        .toggle-slider:before { content: ''; position: absolute; width: 16px; height: 16px; left: 3px; top: 3px; background: #666; border-radius: 50%; transition: 0.2s; }
        .toggle input:checked + .toggle-slider { background: #ffd700; }
        .toggle input:checked + .toggle-slider:before { transform: translateX(18px); background: #000; }
        
        .riemann-zeros { max-height: 150px; overflow-y: auto; }
        .zero-btn { display: block; width: 100%; text-align: left; padding: 6px 10px; background: transparent; border: none; color: #aaa; font-size: 0.8rem; cursor: pointer; border-radius: 4px; font-family: monospace; }
        .zero-btn:hover { background: #2a2a4a; color: #ffd700; }
        
        .export-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
        
        .color-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }
        .color-item label { display: block; font-size: 0.75rem; color: #888; margin-bottom: 4px; }
        
        .section-divider { height: 1px; background: #2a2a4a; margin: 16px 0; }
        
        .legend-box { position: absolute; background: rgba(0, 0, 0, 0.85); border: 1px solid #3a3a5a; border-radius: 6px; padding: 12px; font-size: 0.75rem; color: #e0e0e0; font-family: monospace; min-width: 200px; pointer-events: none; }
        .legend-title { color: #ffd700; font-weight: 600; margin-bottom: 8px; border-bottom: 1px solid #3a3a5a; padding-bottom: 4px; }
        .legend-item { margin: 4px 0; display: flex; justify-content: space-between; }
        .legend-label { color: #aaa; }
        .legend-value { color: #ffd700; margin-left: 12px; }
        
        @media (max-width: 1400px) {
            .main-container { grid-template-columns: 1fr; }
            .documentation { padding: 24px 20px; }
            .canvas-wrapper canvas { max-width: 100%; height: auto; }
        }
        
        @media (max-width: 768px) {
            .header { padding: 20px; }
            .header h1 { font-size: 1.5rem; }
            .tab-btn { padding: 12px 16px; font-size: 0.85rem; }
            .main-container { padding: 10px; gap: 10px; }
            .panel-content { padding: 12px; }
            canvas { width: 100% !important; height: auto !important; }
        }
        
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: #1a1a2a; }
        ::-webkit-scrollbar-thumb { background: #3a3a5a; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #4a4a6a; }
    </style>
</head>
<body>
    <header class="header">
        <h1>Prime-Phase Vector Visualization Tool</h1>
        <div class="subtitle">Mathematical Research Explorer: Riemann Hypothesis and Modular Arithmetic Relationships</div>
        <div class="author">by Wessen Getachew | @7dview</div>
    </header>
    
    <div class="tab-navigation">
        <button class="tab-btn active" onclick="switchTab('visualization')">Visualization</button>
        <button class="tab-btn" onclick="switchTab('parametersweep')">Parameter Sweep</button>
        <button class="tab-btn" onclick="switchTab('gapanalysis')">Prime Gap Analysis</button>
        <button class="tab-btn" onclick="switchTab('sessions')">Sessions</button>
        <button class="tab-btn" onclick="switchTab('documentation')">Mathematical Framework</button>
        <button class="tab-btn" onclick="switchTab('credits')">Credits & References</button>
    </div>
    
    <div id="visualizationTab" class="tab-content active">
        <div class="documentation">
            <div class="doc-section">
                <h2>Overview</h2>
                <p>This visualization tool explores the deep connections between modular arithmetic structures and the Riemann zeta function through complex vector summation. By representing prime numbers as vectors in the complex plane with phases determined by both modular reduction and critical line dynamics, we can observe emergent patterns that may illuminate the distribution of Riemann zeros.</p>
            </div>
            
            <div class="doc-section">
                <h2>Core Mathematical Formula</h2>
                <p>The prime-phase vector function under investigation:</p>
                <div class="formula-block">P<sub>t</sub>(M) = Σ<sub>p≤X</sub> [e<sup>2πiγp/M</sup> / p<sup>β</sup>] · e<sup>-iαt·ln(p)</sup></div>
                <p style="margin-top: 12px;">This function combines modular phase structure (first exponential) with critical line dynamics (second exponential), weighted by a power law decay factor. For detailed parameter explanations and mathematical theory, see the Mathematical Framework tab.</p>
            </div>
        </div>
        
        <div class="main-container">
        <div class="left-panel">
            <div class="panel">
                <div class="panel-header">Primary Parameters</div>
                <div class="panel-content">
                    <div class="control-group">
                        <div class="control-label"><span>Modulus Ring M</span><span class="control-value" id="mValue">37</span></div>
                        <input type="range" id="modulus" min="1" max="10000" value="37">
                        <input type="number" id="modulusInput" min="1" max="10000" value="37" style="margin-top: 6px;">
                    </div>
                    <div class="control-group">
                        <div class="control-label"><span>Critical Line Height t</span><span class="control-value" id="tValue">14.1347</span></div>
                        <input type="range" id="criticalT" min="0" max="1000" step="0.0001" value="14.1347">
                        <input type="number" id="criticalTInput" min="0" max="1000" step="0.0001" value="14.1347" style="margin-top: 6px;">
                    </div>
                    <div class="control-group">
                        <div class="control-label"><span>Prime Cutoff X</span><span class="control-value" id="xValue">200</span></div>
                        <input type="range" id="primeCutoff" min="20" max="100000" value="200">
                        <input type="number" id="primeCutoffInput" min="20" max="100000" value="200" style="margin-top: 6px;">
                    </div>
                </div>
            </div>
            
            <div class="panel" style="margin-top: 16px;">
                <div class="panel-header">Mathematical Parameters</div>
                <div class="panel-content">
                    <div class="control-group">
                        <div class="control-label"><span>Phase Multiplier α</span><span class="control-value" id="alphaValue">1.0000</span></div>
                        <input type="range" id="alpha" min="0" max="100" step="0.0001" value="1">
                        <input type="number" id="alphaInput" min="0" max="100" step="0.0001" value="1" style="margin-top: 6px;">
                    </div>
                    <div class="control-group">
                        <div class="control-label"><span>Magnitude Exponent β</span><span class="control-value" id="betaValue">0.5000</span></div>
                        <input type="range" id="beta" min="0" max="5" step="0.0001" value="0.5">
                        <input type="number" id="betaInput" min="0" max="5" step="0.0001" value="0.5" style="margin-top: 6px;">
                    </div>
                    <div class="control-group">
                        <div class="control-label"><span>Modular Weight γ</span><span class="control-value" id="gammaValue">1.0000</span></div>
                        <input type="range" id="gamma" min="0" max="100" step="0.0001" value="1">
                        <input type="number" id="gammaInput" min="0" max="100" step="0.0001" value="1" style="margin-top: 6px;">
                    </div>
                </div>
            </div>
            
            <div class="panel" style="margin-top: 16px;">
                <div class="panel-header">OEIS Sequence Integration</div>
                <div class="panel-content">
                    <div class="toggle-row">
                        <label>Use OEIS Sequence</label>
                        <label class="toggle"><input type="checkbox" id="useOEISToggle"><span class="toggle-slider"></span></label>
                    </div>
                    <div class="control-group">
                        <label style="font-size: 0.8rem; color: #aaa; margin-bottom: 4px; display: block;">Select Sequence</label>
                        <select id="oeisNumber" style="margin-bottom: 8px;">
                            <option value="">-- Choose a sequence --</option>
                            <optgroup label="Prime Numbers (OFFLINE)">
                                <option value="A000040">A000040 - Prime numbers (1200+ terms)</option>
                                <option value="A001359">A001359 - Lesser of twin primes (200 terms)</option>
                                <option value="A006512">A006512 - Greater of twin primes (200 terms)</option>
                                <option value="A000668">A000668 - Mersenne primes (8 terms)</option>
                                <option value="A019434">A019434 - Fermat primes (5 terms)</option>
                            </optgroup>
                            <optgroup label="Fibonacci & Lucas (OFFLINE)">
                                <option value="A000045">A000045 - Fibonacci numbers (100 terms)</option>
                                <option value="A000032">A000032 - Lucas numbers (100 terms)</option>
                                <option value="A001519">A001519 - Fibonacci odd-indexed (50 terms)</option>
                            </optgroup>
                            <optgroup label="Powers & Polygonal (OFFLINE)">
                                <option value="A000079">A000079 - Powers of 2 (75 terms)</option>
                                <option value="A000244">A000244 - Powers of 3 (50 terms)</option>
                                <option value="A000290">A000290 - Perfect squares (100 terms)</option>
                                <option value="A000578">A000578 - Perfect cubes (100 terms)</option>
                                <option value="A000217">A000217 - Triangular numbers (100 terms)</option>
                                <option value="A000326">A000326 - Pentagonal numbers (100 terms)</option>
                                <option value="A000384">A000384 - Hexagonal numbers (100 terms)</option>
                            </optgroup>
                            <optgroup label="Factorials & Combinatorics (OFFLINE)">
                                <option value="A000142">A000142 - Factorial numbers (21 terms)</option>
                                <option value="A000108">A000108 - Catalan numbers (31 terms)</option>
                                <option value="A000984">A000984 - Central binomial (31 terms)</option>
                            </optgroup>
                            <optgroup label="Custom Upload">
                                <option value="UPLOAD">Upload custom sequence file...</option>
                            </optgroup>
                        </select>
                        <input type="text" id="oeisCustom" placeholder="e.g., A000001" style="display: none; margin-bottom: 8px;">
                    </div>
                    <div class="control-group">
                        <label style="font-size: 0.8rem; color: #aaa; margin-bottom: 4px; display: block;">Terms to Fetch</label>
                        <input type="number" id="oeisTermCount" min="10" max="10000" value="1000" placeholder="10-10000">
                    </div>
                    <button class="btn btn-secondary" onclick="loadOEISSequence()" style="margin-top: 8px;">Load Sequence</button>
                    
                    <div style="display: none;" id="uploadSection">
                        <div class="section-divider"></div>
                        <label style="font-size: 0.8rem; color: #aaa; margin-bottom: 4px; display: block;">Upload Sequence File</label>
                        <input type="file" id="sequenceFile" accept=".txt,.csv,.json" style="display: none;">
                        <button class="btn btn-secondary" onclick="document.getElementById('sequenceFile').click()" style="margin-bottom: 8px;">Choose File</button>
                        <div style="font-size: 0.75rem; color: #888; margin-bottom: 8px;">
                            Supported formats:<br>
                            • Text file: one number per line<br>
                            • CSV: comma-separated values<br>
                            • JSON: array of numbers [1,2,3,...]
                        </div>
                        <button class="btn" onclick="uploadSequence()" style="margin-top: 4px;">Process Upload</button>
                    </div>
                    
                    <div id="oeisStatus" style="font-size: 0.75rem; color: #888; margin-top: 8px; min-height: 20px;"></div>
                    <div id="oeisInfo" style="font-size: 0.75rem; color: #aaa; margin-top: 8px; padding: 8px; background: #1a1a2a; border-radius: 4px; display: none;">
                        <div style="color: #ffd700; font-weight: 600; margin-bottom: 4px;">Sequence Info:</div>
                        <div id="oeisName" style="margin-bottom: 4px;"></div>
                        <div id="oeisLoaded"></div>
                    </div>
                </div>
            </div>
            
            <div class="panel" style="margin-top: 16px;">
                <div class="panel-header">Riemann Zero Presets</div>
                <div class="panel-content">
                    <div class="riemann-zeros" id="zerosList"></div>
                </div>
            </div>
            
                    <div class="control-group">
                        <label style="font-size: 0.8rem; color: #aaa; margin-bottom: 4px; display: block;">Display Type</label>
                        <select id="vizMode" onchange="compute()">
                            <option value="vector">Vector Path (Default)</option>
                            <option value="heatmap">Heat Map Density</option>
                            <option value="spiral">Logarithmic Spiral</option>
                            <option value="contour">Contour Rings</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label style="font-size: 0.8rem; color: #aaa; margin-bottom: 4px; display: block;">Color Scheme</label>
                        <select id="colorScheme" onchange="render(); renderPhaseSpace();">
                            <option value="default">Blue-Red Gradient</option>
                            <option value="fire">Fire (Yellow-Orange-Red)</option>
                            <option value="plasma">Plasma (Purple-Pink-Yellow)</option>
                            <option value="viridis">Viridis (Purple-Green-Yellow)</option>
                            <option value="cool" selected>Cool (Cyan-Blue-Purple)</option>
                            <option value="thermal">Thermal (Black-Red-Yellow-White)</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <div class="control-label"><span>Canvas Zoom</span><span class="control-value" id="canvasZoomValue">100%</span></div>
                        <input type="range" id="canvasZoomSlider" min="50" max="200" value="100">
                    </div>
                </div>
            </div>
                <div class="panel-content">
                    <div class="toggle-row">
                        <label>Depth Gradient Coloring</label>
                        <label class="toggle"><input type="checkbox" id="useGradient"><span class="toggle-slider"></span></label>
                    </div>
                    <div class="section-divider"></div>
                    <div class="color-grid">
                        <div class="color-item">
                            <label>Path Start Color</label>
                            <input type="color" id="pathColor" value="#64c8ff">
                        </div>
                        <div class="color-item">
                            <label>Path End Color</label>
                            <input type="color" id="pathEndColor" value="#ff6464">
                        </div>
                        <div class="color-item">
                            <label>Result Vector</label>
                            <input type="color" id="resultColor" value="#ffd700">
                        </div>
                        <div class="color-item">
                            <label>Grid Lines</label>
                            <input type="color" id="gridColor" value="#ffffff">
                        </div>
                        <div class="color-item">
                            <label>Origin Point</label>
                            <input type="color" id="originColor" value="#00ffff">
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="panel" style="margin-top: 16px;">
                <div class="panel-header">Animation Controls</div>
                <div class="panel-content">
                    <button class="btn" id="animateBtn" onclick="toggleAnimation()" style="margin-bottom: 8px;">Animate t Parameter</button>
                    <button class="btn btn-secondary" onclick="resetAnimation()" style="margin-bottom: 12px;">Reset to First Zero</button>
                    <div class="control-group">
                        <div class="control-label"><span>Animation Speed</span><span class="control-value" id="speedValue">1.0</span></div>
                        <input type="range" id="animSpeed" min="0.1" max="5" step="0.1" value="1">
                    </div>
                </div>
            </div>
        </div>
        
        <div class="center-panel">
            <div class="panel canvas-container">
                <div class="panel-header">
                    <span>Main Vector Space Visualization</span>
                </div>
                <div class="canvas-wrapper" id="mainWrapper">
                    <canvas id="mainCanvas" width="1200" height="800"></canvas>
                    <div class="canvas-overlay">
                        <button class="overlay-btn" onclick="resetView('main')">Reset View</button>
                    </div>
                </div>
            </div>
            
            <div class="panel" style="margin-top: 16px;">
                <div class="panel-header">
                    <span>Phase Space Trajectory</span>
                </div>
                <div class="canvas-wrapper" id="phaseWrapper">
                    <canvas id="phaseCanvas" width="1200" height="300"></canvas>
                    <div class="canvas-overlay">
                        <button class="overlay-btn" onclick="resetView('phase')">Reset View</button>
                    </div>
                </div>
            </div>
            
            <div class="panel" style="margin-top: 16px;">
                <div class="panel-header">
                    <span>Magnitude Evolution History</span>
                </div>
                <div class="toggle-row" style="padding: 8px 16px;">
                    <label>Enable History Tracking</label>
                    <label class="toggle"><input type="checkbox" id="enableHistory" checked><span class="toggle-slider"></span></label>
                </div>
                <div class="canvas-wrapper" id="historyWrapper">
                    <canvas id="historyCanvas" width="1200" height="200"></canvas>
                    <div class="canvas-overlay">
                        <button class="overlay-btn" onclick="resetView('history')">Reset View</button>
                    </div>
                </div>
                <div style="padding: 8px 16px; font-size: 0.75rem; color: #888; display: flex; justify-content: space-between; align-items: center;">
                    <span id="historyStats">Data Points: 0</span>
                    <button class="btn btn-secondary" style="padding: 4px 10px; font-size: 0.75rem;" onclick="clearHistory()">Clear History</button>
                </div>
            </div>
        </div>
        
        <div class="right-panel">
            <div class="panel">
                <div class="panel-header">Primary Diagnostics</div>
                <div class="panel-content">
                    <div class="stats-grid">
                        <div class="stat-item">
                            <div class="stat-label">Vector Magnitude |P<sub>t</sub>|</div>
                            <div class="stat-value" id="statMagnitude">0.000000</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-label">Coherence Score C<sub>t</sub></div>
                            <div class="stat-value" id="statCoherence">0.000000</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-label">Real Component ℜ(P<sub>t</sub>)</div>
                            <div class="stat-value" id="statReal">0.000000</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-label">Imaginary Component ℑ(P<sub>t</sub>)</div>
                            <div class="stat-value" id="statImag">0.000000</div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="panel" style="margin-top: 16px;">
                <div class="panel-header">Vector Path Metrics</div>
                <div class="panel-content">
                    <div class="stats-grid">
                        <div class="stat-item">
                            <div class="stat-label">Prime Count</div>
                            <div class="stat-value" id="statPrimeCount">0</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-label">Total Path Length</div>
                            <div class="stat-value" id="statPathLength">0.0000</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-label">Efficiency Ratio</div>
                            <div class="stat-value" id="statEfficiency">0.000000</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-label">Maximum Excursion</div>
                            <div class="stat-value" id="statMaxExcursion">0.0000</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-label">Winding Number</div>
                            <div class="stat-value" id="statWinding">0.0000</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-label">Cancellation Index</div>
                            <div class="stat-value" id="statCancellation">0.000000</div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="panel" style="margin-top: 16px;">
                <div class="panel-header">Display Configuration</div>
                <div class="panel-content">
                    <div class="toggle-row">
                        <label>Show Vector Path</label>
                        <label class="toggle"><input type="checkbox" id="showPath" checked><span class="toggle-slider"></span></label>
                    </div>
                    <div class="toggle-row">
                        <label>Show Grid Lines</label>
                        <label class="toggle"><input type="checkbox" id="showGrid" checked><span class="toggle-slider"></span></label>
                    </div>
                    <div class="toggle-row">
                        <label>Show Adaptive Legend</label>
                        <label class="toggle"><input type="checkbox" id="showLegend" checked><span class="toggle-slider"></span></label>
                    </div>
                    <div class="section-divider"></div>
                    <div class="control-group">
                        <div class="control-label"><span>Path Opacity</span><span class="control-value" id="opacityValue">100%</span></div>
                        <input type="range" id="pathOpacity" min="5" max="100" value="100">
                    </div>
                    <div class="control-group">
                        <div class="control-label"><span>Grid Opacity</span><span class="control-value" id="gridOpacityValue">100%</span></div>
                        <input type="range" id="gridOpacity" min="5" max="100" value="100">
                    </div>
                </div>
            </div>
            
            <div class="panel" style="margin-top: 16px;">
                <div class="panel-header">Data Export</div>
                <div class="panel-content">
                    <div class="export-grid">
                        <button class="btn btn-secondary" onclick="exportAllPNG()">All PNG</button>
                        <button class="btn btn-secondary" onclick="exportAllSVG()">All SVG</button>
                        <button class="btn btn-secondary" onclick="exportCSV()">Vector CSV</button>
                        <button class="btn btn-secondary" onclick="exportHistory()">History CSV</button>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <div id="parametersweepTab" class="tab-content">
        <div class="documentation">
            <div class="doc-section">
                <h2>Parameter Space Explorer</h2>
                <p>Automatically scan parameter ranges to discover patterns, find zeros, and visualize the mathematical landscape of the prime-phase vector function.</p>
                
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 24px 0;">
                    <div class="panel" style="margin: 0;">
                        <div class="panel-header">Sweep Configuration</div>
                        <div class="panel-content">
                            <div class="control-group">
                                <label style="font-size: 0.85rem; color: #aaa; margin-bottom: 6px; display: block;">Sweep Type</label>
                                <select id="sweepType" onchange="updateSweepUI()">
                                    <option value="M_t">M vs t (Modulus vs Height)</option>
                                    <option value="alpha_beta">α vs β (Phase vs Magnitude)</option>
                                    <option value="t_scan">t-Scan (Zero Detection)</option>
                                    <option value="M_scan">M-Scan (Resonance Detection)</option>
                                </select>
                            </div>
                            
                            <div id="sweep_M_t" class="sweep-config">
                                <div class="control-group">
                                    <label style="font-size: 0.8rem; color: #aaa; margin-bottom: 4px; display: block;">M Range</label>
                                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                                        <input type="number" id="M_min" value="1" min="1" max="1000" placeholder="Min">
                                        <input type="number" id="M_max" value="100" min="1" max="10000" placeholder="Max">
                                    </div>
                                </div>
                                <div class="control-group">
                                    <label style="font-size: 0.8rem; color: #aaa; margin-bottom: 4px; display: block;">t Range</label>
                                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                                        <input type="number" id="t_min" value="0" min="0" max="1000" step="0.1" placeholder="Min">
                                        <input type="number" id="t_max" value="50" min="0" max="1000" step="0.1" placeholder="Max">
                                    </div>
                                </div>
                            </div>
                            
                            <div id="sweep_alpha_beta" class="sweep-config" style="display: none;">
                                <div class="control-group">
                                    <label style="font-size: 0.8rem; color: #aaa; margin-bottom: 4px; display: block;">α Range</label>
                                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                                        <input type="number" id="alpha_min" value="0" min="0" max="10" step="0.1" placeholder="Min">
                                        <input type="number" id="alpha_max" value="2" min="0" max="10" step="0.1" placeholder="Max">
                                    </div>
                                </div>
                                <div class="control-group">
                                    <label style="font-size: 0.8rem; color: #aaa; margin-bottom: 4px; display: block;">β Range</label>
                                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                                        <input type="number" id="beta_min" value="0" min="0" max="2" step="0.05" placeholder="Min">
                                        <input type="number" id="beta_max" value="1" min="0" max="5" step="0.05" placeholder="Max">
                                    </div>
                                </div>
                            </div>
                            
                            <div id="sweep_t_scan" class="sweep-config" style="display: none;">
                                <div class="control-group">
                                    <label style="font-size: 0.8rem; color: #aaa; margin-bottom: 4px; display: block;">t Range for Zero Detection</label>
                                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                                        <input type="number" id="tscan_min" value="0" min="0" max="1000" step="0.1" placeholder="Min">
                                        <input type="number" id="tscan_max" value="100" min="0" max="1000" step="0.1" placeholder="Max">
                                    </div>
                                </div>
                                <div class="control-group">
                                    <label style="font-size: 0.8rem; color: #aaa; margin-bottom: 4px; display: block;">Step Size</label>
                                    <input type="number" id="tscan_step" value="0.1" min="0.001" max="1" step="0.001">
                                </div>
                                <div class="control-group">
                                    <label style="font-size: 0.8rem; color: #aaa; margin-bottom: 4px; display: block;">Detection Threshold</label>
                                    <input type="number" id="tscan_threshold" value="0.01" min="0.0001" max="1" step="0.0001">
                                </div>
                            </div>
                            
                            <div id="sweep_M_scan" class="sweep-config" style="display: none;">
                                <div class="control-group">
                                    <label style="font-size: 0.8rem; color: #aaa; margin-bottom: 4px; display: block;">M Range for Resonance Detection</label>
                                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                                        <input type="number" id="Mscan_min" value="1" min="1" max="1000" placeholder="Min">
                                        <input type="number" id="Mscan_max" value="500" min="1" max="10000" placeholder="Max">
                                    </div>
                                </div>
                                <div class="control-group">
                                    <label style="font-size: 0.8rem; color: #aaa; margin-bottom: 4px; display: block;">Step Size</label>
                                    <input type="number" id="Mscan_step" value="1" min="1" max="100">
                                </div>
                            </div>
                            
                            <div class="control-group">
                                <label style="font-size: 0.8rem; color: #aaa; margin-bottom: 4px; display: block;">Resolution (Grid Size)</label>
                                <select id="sweepResolution">
                                    <option value="25">25×25 (Fast)</option>
                                    <option value="50" selected>50×50 (Balanced)</option>
                                    <option value="100">100×100 (Detailed)</option>
                                    <option value="200">200×200 (High Quality)</option>
                                </select>
                            </div>
                            
                            <div class="control-group">
                                <label style="font-size: 0.8rem; color: #aaa; margin-bottom: 4px; display: block;">Metric to Display</label>
                                <select id="sweepMetric">
                                    <option value="magnitude">Magnitude |P_t|</option>
                                    <option value="coherence">Coherence Score</option>
                                    <option value="real">Real Component</option>
                                    <option value="imag">Imaginary Component</option>
                                    <option value="phase">Phase Angle</option>
                                </select>
                            </div>
                            
                            <button class="btn" onclick="runParameterSweep()" style="width: 100%; margin-top: 12px;">Start Sweep</button>
                            <button class="btn btn-secondary" onclick="cancelSweep()" style="width: 100%; margin-top: 8px; display: none;" id="cancelSweepBtn">Cancel Sweep</button>
                        </div>
                    </div>
                    
                    <div class="panel" style="margin: 0;">
                        <div class="panel-header">Sweep Status</div>
                        <div class="panel-content">
                            <div id="sweepStatus" style="font-size: 0.85rem; color: #888; margin-bottom: 12px; min-height: 60px;">
                                Configure sweep parameters and click "Start Sweep" to begin analysis.
                            </div>
                            <div id="sweepProgress" style="display: none;">
                                <div style="background: #1a1a2a; border-radius: 4px; height: 24px; overflow: hidden; margin-bottom: 8px;">
                                    <div id="sweepProgressBar" style="background: linear-gradient(90deg, #ffd700, #ffaa00); height: 100%; width: 0%; transition: width 0.3s;"></div>
                                </div>
                                <div style="font-size: 0.75rem; color: #888; font-family: monospace;">
                                    <span id="sweepProgressText">0 / 0 points computed</span>
                                </div>
                            </div>
                            <div id="sweepResults" style="display: none; margin-top: 16px;">
                                <div class="stat-item">
                                    <div class="stat-label">Computation Time</div>
                                    <div class="stat-value" id="sweepTime">0.00s</div>
                                </div>
                                <div class="stat-item" style="margin-top: 8px;">
                                    <div class="stat-label">Points Computed</div>
                                    <div class="stat-value" id="sweepPoints">0</div>
                                </div>
                                <div class="stat-item" style="margin-top: 8px;">
                                    <div class="stat-label">Min Value</div>
                                    <div class="stat-value" id="sweepMin">0.000000</div>
                                </div>
                                <div class="stat-item" style="margin-top: 8px;">
                                    <div class="stat-label">Max Value</div>
                                    <div class="stat-value" id="sweepMax">0.000000</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="doc-section">
                <h2>Heatmap Visualization</h2>
                <div class="canvas-wrapper">
                    <canvas id="sweepCanvas" width="1200" height="800" style="width: 100%; background: #000; border-radius: 8px;"></canvas>
                    <div class="canvas-overlay">
                        <button class="overlay-btn" onclick="exportSweepPNG()">Export PNG</button>
                        <button class="overlay-btn" onclick="exportSweepCSV()">Export Data CSV</button>
                    </div>
                </div>
                <div id="sweepLegend" style="margin-top: 16px; padding: 16px; background: #1a1a2a; border-radius: 6px; display: none;">
                    <div style="color: #ffd700; font-weight: 600; margin-bottom: 8px;">Color Scale</div>
                    <div style="display: flex; align-items: center; gap: 12px;">
                        <div style="flex: 1; height: 30px; background: linear-gradient(90deg, #000, #8b0000, #ff4500, #ffa500, #ffff64); border-radius: 4px;"></div>
                        <div style="font-family: monospace; font-size: 0.85rem; display: flex; justify-content: space-between; width: 100%; margin-top: 4px;">
                            <span id="legendMin">0.00</span>
                            <span id="legendMax">1.00</span>
                        </div>
                    </div>
                </div>
                
                <div id="detectedFeatures" style="margin-top: 16px; display: none;">
                    <h3 style="color: #ffd700; margin-bottom: 12px;">Detected Features</h3>
                    <div id="featuresList" style="background: #1a1a2a; padding: 16px; border-radius: 6px; max-height: 300px; overflow-y: auto;"></div>
                </div>
            </div>
        </div>
    </div>
    
    <div id="gapanalysisTab" class="tab-content">
        <div class="documentation">
            <div class="doc-section">
                <h2>Prime Gap Decomposition of ζ(2) = π²/6</h2>
                <p style="font-style: italic; color: #ffd700;">By Wessen Getachew, 2025</p>
                
                <h3>Theoretical Foundation</h3>
                <p>Using the Phase Law, ζ(2) can be decomposed into products of prime gap families:</p>
                <div class="formula-block">ζ(2) = ∏<sub>(gap=0)</sub> P₀ × ∏<sub>(gap=2)</sub> P₂ × ∏<sub>(gap=4)</sub> P₄ × ∏<sub>(gap=6)</sub> P₆ × ... → π²/6</div>
                
                <h3>Method</h3>
                <p>Each P<sub>g</sub> is the product over primes in that gap family:</p>
                <div class="formula-block">P<sub>g</sub> = ∏ (p² / (p² - 1)), for primes whose smallest gap family = g</div>
                <p>Where the "smallest gap family" is the difference to the next prime. For example:</p>
                <ul>
                    <li><strong>Gap 0:</strong> Prime 2 only (no next prime with gap 0)</li>
                    <li><strong>Gap 2:</strong> Twin primes (3,5), (5,7), (11,13), (17,19)...</li>
                    <li><strong>Gap 4:</strong> Cousin primes (7,11), (13,17), (19,23)...</li>
                    <li><strong>Gap 6:</strong> Sexy primes (5,11), (7,13), (11,17), (13,19)...</li>
                </ul>
                
                <h3>Theoretical Results</h3>
                <div style="background: #1a1a2a; padding: 16px; border-radius: 6px; margin: 16px 0;">
                    <p style="margin-bottom: 8px;"><strong>Gap 0 (Prime 2 only):</strong> P₀ = 4/3 ≈ 1.3333</p>
                    <p style="margin-bottom: 8px;"><strong>Gap 2 (Twin primes):</strong> P₂ ≈ (9/8)(25/24)(121/120)... ≈ 1.1887 (first 10 twins)</p>
                    <p style="margin-bottom: 8px;"><strong>Gap 4 (Cousin primes):</strong> P₄ ≈ 1.0321</p>
                    <p><strong>Gap 6 (Sexy primes):</strong> P₆ ≈ 1.0048</p>
                </div>
                
                <h3>Progressive Convergence</h3>
                <div class="formula-block">ζ(2) ≈ 1.3333 × 1.1887 × 1.0321 × 1.0048 × ... ≈ 1.644934 ≈ π²/6</div>
            </div>
            
            <div class="doc-section">
                <h2>Computational Analysis</h2>
                <p>Run tests to verify the prime gap decomposition with actual prime data:</p>
                
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px; margin: 20px 0;">
                    <div>
                        <label style="font-size: 0.85rem; color: #aaa; margin-bottom: 6px; display: block;">Maximum Prime</label>
                        <input type="number" id="gapTestMax" value="10000" min="100" max="100000" style="width: 100%;">
                    </div>
                    <div>
                        <label style="font-size: 0.85rem; color: #aaa; margin-bottom: 6px; display: block;">Max Gap to Analyze</label>
                        <input type="number" id="gapTestMaxGap" value="20" min="2" max="100" step="2" style="width: 100%;">
                    </div>
                </div>
                
                <button class="btn" onclick="runGapAnalysis()" style="width: 100%; margin-bottom: 16px;">Run Gap Analysis</button>
                
                <div id="gapAnalysisStatus" style="font-size: 0.85rem; color: #888; margin-bottom: 12px; min-height: 20px;"></div>
                
                <div id="gapResults" style="display: none;">
                    <div style="background: #1a1a2a; border-radius: 6px; padding: 16px; margin-bottom: 16px;">
                        <h3 style="color: #ffd700; margin-bottom: 12px;">Summary Statistics</h3>
                        <div id="gapSummary" style="font-family: monospace; font-size: 0.9rem; line-height: 1.8;"></div>
                    </div>
                    
                    <div style="background: #1a1a2a; border-radius: 6px; padding: 16px; margin-bottom: 16px;">
                        <h3 style="color: #ffd700; margin-bottom: 12px;">Gap Family Products</h3>
                        <div id="gapFamilies" style="font-family: monospace; font-size: 0.85rem; line-height: 1.8; max-height: 400px; overflow-y: auto;"></div>
                    </div>
                    
                    <div style="background: #1a1a2a; border-radius: 6px; padding: 16px; margin-bottom: 16px;">
                        <h3 style="color: #ffd700; margin-bottom: 12px;">Progressive Product Convergence</h3>
                        <canvas id="convergenceCanvas" width="1200" height="400" style="width: 100%; height: auto; background: #0a0a10; border-radius: 4px;"></canvas>
                    </div>
                    
                    <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 12px;">
                        <button class="btn btn-secondary" onclick="exportGapCSV()">Export CSV</button>
                        <button class="btn btn-secondary" onclick="exportGapChart()">Export Chart PNG</button>
                        <button class="btn btn-secondary" onclick="exportGapReport()">Export Full Report</button>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <div id="sessionsTab" class="tab-content">
        <div class="documentation">
            <div class="doc-section">
                <h2>OEIS Sequence Integration</h2>
                <p>Replace prime numbers with any integer sequence from the Online Encyclopedia of Integer Sequences to explore mathematical patterns across different number families.</p>
                
                <h3>Available Sequences</h3>
                <p>The tool includes 18 pre-loaded OEIS sequences for offline use:</p>
                
                <div style="background: #1a1a2a; padding: 16px; border-radius: 6px; margin: 16px 0;">
                    <h4 style="color: #ffd700; margin-bottom: 12px;">Prime Numbers & Variants</h4>
                    <ul>
                        <li><strong>A000040</strong> - Prime numbers (1,200+ terms)</li>
                        <li><strong>A001359</strong> - Lesser of twin primes (200 terms)</li>
                        <li><strong>A006512</strong> - Greater of twin primes (200 terms)</li>
                        <li><strong>A000668</strong> - Mersenne primes (8 known terms)</li>
                        <li><strong>A019434</strong> - Fermat primes (5 known terms)</li>
                    </ul>
                </div>
                
                <div style="background: #1a1a2a; padding: 16px; border-radius: 6px; margin: 16px 0;">
                    <h4 style="color: #ffd700; margin-bottom: 12px;">Recursive Sequences</h4>
                    <ul>
                        <li><strong>A000045</strong> - Fibonacci numbers (100 terms)</li>
                        <li><strong>A000032</strong> - Lucas numbers (100 terms)</li>
                        <li><strong>A001519</strong> - Fibonacci odd-indexed (50 terms)</li>
                    </ul>
                </div>
                
                <div style="background: #1a1a2a; padding: 16px; border-radius: 6px; margin: 16px 0;">
                    <h4 style="color: #ffd700; margin-bottom: 12px;">Power Sequences</h4>
                    <ul>
                        <li><strong>A000079</strong> - Powers of 2 (75 terms)</li>
                        <li><strong>A000244</strong> - Powers of 3 (50 terms)</li>
                        <li><strong>A000290</strong> - Perfect squares (100 terms)</li>
                        <li><strong>A000578</strong> - Perfect cubes (100 terms)</li>
                    </ul>
                </div>
                
                <div style="background: #1a1a2a; padding: 16px; border-radius: 6px; margin: 16px 0;">
                    <h4 style="color: #ffd700; margin-bottom: 12px;">Figurate Numbers</h4>
                    <ul>
                        <li><strong>A000217</strong> - Triangular numbers (100 terms)</li>
                        <li><strong>A000326</strong> - Pentagonal numbers (100 terms)</li>
                        <li><strong>A000384</strong> - Hexagonal numbers (100 terms)</li>
                    </ul>
                </div>
                
                <div style="background: #1a1a2a; padding: 16px; border-radius: 6px; margin: 16px 0;">
                    <h4 style="color: #ffd700; margin-bottom: 12px;">Combinatorial Sequences</h4>
                    <ul>
                        <li><strong>A000142</strong> - Factorial numbers (21 terms)</li>
                        <li><strong>A000108</strong> - Catalan numbers (31 terms)</li>
                        <li><strong>A000984</strong> - Central binomial coefficients (31 terms)</li>
                    </ul>
                </div>
                
                <h3>How to Use OEIS Sequences</h3>
                <div style="background: #1a1a2a; padding: 16px; border-radius: 6px; margin: 16px 0;">
                    <h4 style="color: #ffd700; margin-bottom: 8px;">Method 1: Select from Dropdown</h4>
                    <ol>
                        <li>In the Visualization tab, find the "OEIS Sequence Integration" panel in the left sidebar</li>
                        <li>Toggle "Use OEIS Sequence" to enable sequence mode</li>
                        <li>Select a sequence from the dropdown menu (organized by category)</li>
                        <li>Click "Load Sequence" to replace primes with your chosen sequence</li>
                        <li>The visualization will update automatically to show the new pattern</li>
                    </ol>
                </div>
                
                <div style="background: #1a1a2a; padding: 16px; border-radius: 6px; margin: 16px 0;">
                    <h4 style="color: #ffd700; margin-bottom: 8px;">Method 2: Upload Custom Sequence</h4>
                    <ol>
                        <li>Select "Custom (Upload)" from the sequence dropdown</li>
                        <li>Prepare a text file with one number per line (plain integers only)</li>
                        <li>Click "Choose File" to upload your sequence</li>
                        <li>The tool will automatically parse and load your sequence</li>
                        <li>Your custom sequence name will appear in the visualization</li>
                    </ol>
                </div>
                
                <div style="background: #1a1a2a; padding: 16px; border-radius: 6px; margin: 16px 0;">
                    <h4 style="color: #ffd700; margin-bottom: 8px;">Method 3: Enter OEIS Code Manually</h4>
                    <ol>
                        <li>Select "Custom (Manual)" from the sequence dropdown</li>
                        <li>Enter an OEIS code in the format A000000 (e.g., A000001)</li>
                        <li>Click "Load Sequence" to attempt loading</li>
                        <li>Note: Only the 18 pre-loaded sequences are available offline</li>
                        <li>For other sequences, use the upload method with data from oeis.org</li>
                    </ol>
                </div>
                
                <h3>Interpreting Results</h3>
                <p>When using OEIS sequences instead of primes, the visualization reveals how different mathematical structures interact with modular arithmetic and phase relationships. Key observations:</p>
                <ul>
                    <li><strong>Regular sequences</strong> (powers of 2, squares) create highly symmetric patterns</li>
                    <li><strong>Recursive sequences</strong> (Fibonacci, Lucas) show spiral-like growth patterns</li>
                    <li><strong>Prime-related sequences</strong> (twin primes, Mersenne primes) display irregular but constrained behavior</li>
                    <li><strong>Combinatorial sequences</strong> (factorials, Catalan) exhibit rapid divergence</li>
                </ul>
                
                <h3>Research Applications</h3>
                <p>OEIS integration enables exploration of:</p>
                <ul>
                    <li>Modular distribution patterns across different number families</li>
                    <li>Phase interference effects in non-prime sequences</li>
                    <li>Convergence behavior of vector sums for various mathematical structures</li>
                    <li>Comparative analysis between prime and non-prime number patterns</li>
                </ul>
                
                <div style="background: #2a2a4a; border-left: 4px solid #ffd700; padding: 16px; margin: 20px 0;">
                    <p style="margin: 0;"><strong>Note:</strong> For sequences not included in the pre-loaded set, visit <a href="https://oeis.org" target="_blank" style="color: #ffd700;">oeis.org</a> to download sequence data, then use the upload feature to analyze them in this tool.</p>
                </div>
            </div>
        </div>
    </div>
    
    <div id="documentationTab" class="tab-content">
        <div class="documentation">
            <div class="doc-section">
                <h2>Mathematical Framework</h2>
                
                <h3>Parameter Definitions</h3>
                <ul>
                    <li><strong>M (Modulus Ring):</strong> The modular arithmetic base defining the residue class structure. Range: 1 to 10,000. When M=1, all terms map to the same point (complete constructive interference). For M=2, terms alternate between two positions creating maximal structure. Larger M creates denser phase distributions. Special case: M=1 corresponds to gcd(p,1)=1 for all p, placing all vectors at angle 2πγ/1 = 2πγ (a single point on the unit circle).</li>
                    <li><strong>t (Critical Line Height):</strong> The imaginary component of the Riemann zeta function argument s = 1/2 + it. Range: 0 to 1,000. When t corresponds to a Riemann zero, special cancellation patterns emerge. The tool includes 1,000 precomputed Riemann zeros.</li>
                    <li><strong>X (Prime Cutoff):</strong> The upper bound for prime summation. Range: 20 to 100,000. Larger values provide more complete vector sums but require more computational resources.</li>
                    <li><strong>α (Phase Multiplier):</strong> Scaling factor for the critical line phase component. Range: 0 to 100. Standard value is 1, but variations reveal phase sensitivity.</li>
                    <li><strong>β (Magnitude Exponent):</strong> Power law exponent controlling magnitude decay. Range: 0 to 5. The classical value β = 1/2 corresponds to the critical line of ζ(s).</li>
                    <li><strong>γ (Modular Weight):</strong> Coefficient controlling the influence of modular phase structure relative to critical line dynamics. Range: 0 to 100.</li>
                </ul>
                
                <h3>Vector Construction</h3>
                <p>For each prime p ≤ X (or term in custom sequence), we construct a complex vector with two phase components:</p>
                <ul>
                    <li><strong>Modular Phase:</strong> θ<sub>mod</sub> = 2πγp/M, creating a discrete rotational structure based on residue classes. For M=1, all terms map to angle 2πγ (complete alignment). For M=2, terms alternate between 0 and πγ. For gcd(p,M)=1, each coprime p creates a unique phase position.</li>
                    <li><strong>Critical Phase:</strong> θ<sub>crit</sub> = -αt·ln(p), encoding the logarithmic growth structure tied to the Riemann zeta function.</li>
                    <li><strong>Magnitude:</strong> |v<sub>p</sub>| = 1/p<sup>β</sup>, implementing a power law decay matching the analytic structure of L-functions.</li>
                </ul>
                <p><strong>Special Cases:</strong></p>
                <ul>
                    <li>M=1: All vectors point in the same direction → maximum constructive interference</li>
                    <li>M=2: Binary phase structure → alternating pattern between even/odd residues</li>
                    <li>M=p (prime): Creates p-fold rotational symmetry with φ(p)=p-1 coprime positions</li>
                    <li>Large M: Approaches uniform phase distribution on the unit circle</li>
                </ul>
                
                <h3>Statistical Metrics</h3>
                <p>The tool computes real-time diagnostic statistics to quantify vector behavior:</p>
                <ul>
                    <li><strong>Total Magnitude |P<sub>t</sub>|:</strong> The norm of the final cumulative vector, measuring net constructive interference.</li>
                    <li><strong>Coherence Score:</strong> C<sub>t</sub> = 1 - (|P<sub>t</sub>| / Σ|v<sub>p</sub>|), quantifying destructive interference. Values near 1 indicate strong cancellation.</li>
                    <li><strong>Path Length:</strong> Σ|v<sub>p</sub>|, the total distance traversed by the cumulative vector tip through the complex plane.</li>
                    <li><strong>Efficiency Ratio:</strong> |P<sub>t</sub>| / Σ|v<sub>p</sub>|, the ratio of direct distance to total path length. Low values indicate circuitous paths with cancellation.</li>
                    <li><strong>Maximum Excursion:</strong> The furthest distance the cumulative vector reaches from the origin during summation.</li>
                    <li><strong>Winding Number:</strong> The total angular rotation of the cumulative vector divided by 2π. Non-integer values reveal complex phase dynamics.</li>
                    <li><strong>Cancellation Index:</strong> 1 - (|P<sub>t</sub>| / Σ|v<sub>p</sub>|), an alternative measure of interference strength.</li>
                </ul>
            </div>
            
            <div class="doc-section">
                <h2>Research Applications</h2>
                <p>This tool enables investigation of several key mathematical questions:</p>
                <ul>
                    <li><strong>Riemann Hypothesis Connection:</strong> By setting t to known Riemann zeros and exploring parameter space, we can identify modular structures that exhibit enhanced cancellation, potentially revealing algebraic or geometric properties of the zeros.</li>
                    <li><strong>Prime Distribution Patterns:</strong> The cumulative vector path visualizes how prime residue patterns interact with logarithmic phase spacing, offering geometric insight into number-theoretic phenomena.</li>
                    <li><strong>Modular-Analytic Correspondence:</strong> The interplay between discrete modular structure (M, γ) and continuous analytic structure (t, α, β) may illuminate connections between algebraic number theory and complex analysis.</li>
                    <li><strong>Phase Transition Detection:</strong> Monitoring statistics like coherence and winding number as parameters vary can reveal critical thresholds where qualitative behavior changes.</li>
                </ul>
            </div>
            
            <div class="doc-section">
                <h2>Interactive Features</h2>
                <ul>
                    <li><strong>Real-Time Visualization:</strong> All three canvases (main vector space, phase space, magnitude history) update dynamically as parameters change.</li>
                    <li><strong>Riemann Zero Presets:</strong> One-click navigation to the first 1,000 non-trivial Riemann zeros for immediate investigation of zero-correlated behavior.</li>
                    <li><strong>Animation Mode:</strong> Automated scanning through t-parameter space with adjustable speed, enabling observation of continuous transitions.</li>
                    <li><strong>Adaptive Legends:</strong> Each canvas includes a dynamic legend displaying current parameters and key statistics without visual overlap.</li>
                    <li><strong>Zoom and Pan:</strong> Mouse wheel zoom and click-drag panning for detailed examination of vector structures.</li>
                    <li><strong>Color Customization:</strong> Full control over vector path, grid, result vector, and background colors for optimal visual clarity and presentation.</li>
                    <li><strong>High-Resolution Export:</strong> PNG export at 4K resolution (3840×2160) for publication-quality figures, plus SVG for vector graphics and CSV for numerical data.</li>
                    <li><strong>OEIS Integration:</strong> Load custom integer sequences from the Online Encyclopedia of Integer Sequences to replace prime numbers with other mathematically significant sequences.</li>
                </ul>
            </div>
        </div>
    </div>
    
    <div id="creditsTab" class="tab-content">
        <div class="documentation">
            <div class="doc-section">
                <h2>Credits & Attribution</h2>
                
                <h3>Primary Developer</h3>
                <p><strong>Wessen Getachew</strong> (@7dview)</p>
                <ul>
                    <li>Twitter/X: <a href="https://twitter.com/7dview" target="_blank" style="color: #ffd700;">@7dview</a></li>
                    <li>GitHub: <a href="https://wessengetachew.github.io" target="_blank" style="color: #ffd700;">wessengetachew.github.io</a></li>
                </ul>
                <p>Independent mathematical researcher and software developer specializing in interactive visualization tools for advanced number theory concepts. Self-taught in complex mathematical domains including Riemann Hypothesis exploration, prime distribution theory, and modular arithmetic structures.</p>
            </div>
            
            <div class="doc-section">
                <h2>Mathematical Foundations</h2>
                
                <h3>Riemann Zeta Function</h3>
                <p>The Riemann zeta function ζ(s) and its connection to prime numbers forms the theoretical foundation of this tool. The non-trivial zeros of ζ(s) lie on the critical line Re(s) = 1/2, a conjecture known as the Riemann Hypothesis.</p>
                <ul>
                    <li><strong>Riemann, Bernhard (1859):</strong> "Über die Anzahl der Primzahlen unter einer gegebenen Größe" - The foundational paper introducing the zeta function and its connection to primes.</li>
                    <li><strong>Zero Data Source:</strong> The first 1,000 non-trivial zeros are precomputed from established mathematical tables and verified computational sources.</li>
                </ul>
                
                <h3>Modular Arithmetic & Number Theory</h3>
                <ul>
                    <li><strong>Farey Sequences:</strong> Connections to rational approximations and continued fractions.</li>
                    <li><strong>Dirichlet Characters:</strong> Modular structures related to L-functions and prime distribution in arithmetic progressions.</li>
                    <li><strong>Euler's Totient Function:</strong> φ(n) counting coprime integers, fundamental to modular arithmetic analysis.</li>
                </ul>
                
                <h3>Complex Analysis</h3>
                <p>Vector summation in the complex plane provides geometric interpretation of analytic number theory:</p>
                <ul>
                    <li><strong>Euler Product Formula:</strong> Connection between primes and zeta function values.</li>
                    <li><strong>Phase Space Analysis:</strong> Geometric representation of complex function behavior.</li>
                    <li><strong>Winding Number Theory:</strong> Topological invariants in complex analysis.</li>
                </ul>
            </div>
            
            <div class="doc-section">
                <h2>Technical Implementation</h2>
                
                <h3>Algorithms & Computation</h3>
                <ul>
                    <li><strong>Sieve of Eratosthenes:</strong> Classical algorithm for efficient prime number generation up to 100,000.</li>
                    <li><strong>Complex Vector Summation:</strong> Real-time computation of cumulative vector paths with phase and magnitude tracking.</li>
                    <li><strong>Statistical Analysis:</strong> Coherence metrics, winding numbers, and efficiency ratios computed on-the-fly.</li>
                </ul>
                
                <h3>Visualization Technologies</h3>
                <ul>
                    <li><strong>HTML5 Canvas:</strong> High-performance 2D graphics rendering for complex visualizations.</li>
                    <li><strong>JavaScript ES6+:</strong> Modern web technologies enabling real-time parameter manipulation.</li>
                    <li><strong>Adaptive Legends:</strong> Dynamic positioning system to prevent visual overlap with data.</li>
                    <li><strong>Export Capabilities:</strong> PNG (4K resolution), SVG (vector graphics), and CSV (numerical data).</li>
                </ul>
                
                <h3>OEIS Integration & Custom Sequences</h3>
                <p>The tool supports multiple ways to load integer sequences:</p>
                <ul>
                    <li><strong>Built-in Sequences:</strong> 18 hardcoded sequences available offline, including primes, Fibonacci, powers, polygonal numbers, factorials, and Catalan numbers. These work without internet connection.</li>
                    <li><strong>Custom File Upload:</strong> Upload your own sequences in three formats:
                        <ul style="margin-left: 20px; margin-top: 8px;">
                            <li><strong>Text file (.txt):</strong> One number per line or space-separated</li>
                            <li><strong>CSV file (.csv):</strong> Comma-separated values</li>
                            <li><strong>JSON file (.json):</strong> Array format: [1, 2, 3, 5, 8, ...]</li>
                        </ul>
                    </li>
                    <li><strong>Example sequence files you could create:</strong>
                        <ul style="margin-left: 20px; margin-top: 8px;">
                            <li>Your own research data</li>
                            <li>Experimental measurements</li>
                            <li>Custom mathematical sequences</li>
                            <li>Filtered prime subsets</li>
                            <li>Any positive integer sequence up to 10,000 terms</li>
                        </ul>
                    </li>
                </ul>
                <p>When uploading custom sequences, the filename becomes the sequence name displayed in visualizations. Ensure all values are positive integers.</p>
            </div>
            
            <div class="doc-section">
                <h2>Research Context</h2>
                
                <h3>Related Projects</h3>
                <p>This tool is part of a broader research program exploring geometric and algebraic approaches to classical number theory problems:</p>
                <ul>
                    <li><strong>Farey Triangle & Cayley Transform:</strong> Hyperbolic geometry and conformal mappings in number theory.</li>
                    <li><strong>Modular Rings Visualization:</strong> Geometric representation of residue class structures.</li>
                    <li><strong>Interactive Modular Lifting Rings:</strong> Exploring Riemann Hypothesis connections through modular arithmetic.</li>
                    <li><strong>Modular Sieve Calculator:</strong> Computing π and ζ(2n) using Euler product decompositions.</li>
                </ul>
                
                <h3>Educational Mission</h3>
                <p>These visualization tools serve dual purposes: advancing mathematical research through computational exploration and making complex concepts accessible to students and researchers. By bridging abstract theory with intuitive geometric representation, the tools facilitate deeper understanding of fundamental mathematical structures.</p>
            </div>
            
            <div class="doc-section">
                <h2>License & Usage</h2>
                <p>This visualization tool is created for mathematical research and educational purposes. Users are encouraged to:</p>
                <ul>
                    <li>Explore parameter spaces to discover novel patterns</li>
                    <li>Export high-resolution visualizations for academic presentations</li>
                    <li>Share findings with the mathematical community</li>
                    <li>Provide feedback and suggestions for improvements</li>
                </ul>
                <p><strong>Citation:</strong> When using this tool in academic work, please credit Wessen Getachew (@7dview) and reference the tool's GitHub repository.</p>
            </div>
            
            <div class="doc-section">
                <h2>Acknowledgments</h2>
                <p>Development of this tool benefited from:</p>
                <ul>
                    <li>The global mathematics research community and publicly available mathematical datasets</li>
                    <li>Open-source software libraries and web standards enabling sophisticated browser-based computation</li>
                    <li>Historical mathematical work spanning centuries, from Euler to Riemann to contemporary researchers</li>
                    <li>The Online Encyclopedia of Integer Sequences (OEIS) for providing comprehensive sequence data</li>
                </ul>
                
                <p style="margin-top: 24px; padding-top: 16px; border-top: 1px solid #2a2a4a; color: #888; font-size: 0.9rem;">
                    <strong>Version:</strong> 1.0 | <strong>Last Updated:</strong> 2025<br>
                    For questions, collaborations, or bug reports, contact via Twitter/X @7dview
                </p>
            </div>
        </div>
    </div>
    
    <script>
        const riemannZeros = [14.134725,21.022040,25.010858,30.424876,32.935062,37.586178,40.918720,43.327073,48.005151,49.773832,52.970321,56.446248,59.347044,60.831779,65.112544,67.079811,69.546402,72.067158,75.704691,77.144840,79.337375,82.910381,84.735493,87.425274,88.809111,92.491899,94.651344,95.870634,98.831194,101.317851,103.725538,105.446623,107.168611,111.029535,111.874659,114.320220,116.226680,118.790782,121.370125,122.946829,124.256819,127.516683,129.578704,131.087688,133.497737,134.756509,138.116042,139.736208,141.123707,143.111845,146.000982,147.422765,150.053183,150.925257,153.024693,156.112909,157.597591,158.849988,161.188964,163.030709,165.537069,167.184439,169.094515,169.911976,173.411536,174.754191,176.441434,178.377407,179.916484,182.207078,184.874467,185.598783,187.228922,189.416158,192.026656,193.079726,195.265396,196.876481,198.015309,201.264751,202.493594,204.189671,205.394698,207.906258,209.576509,211.690862,213.347919,214.547044,216.169538,219.067596,220.714918,221.430705,224.006751,224.983324,227.421444,229.337413,231.250188,231.987235,233.693027,236.524229,237.769132,239.551545,241.049219,242.879463,244.070508,246.017930,247.056525,248.074508,249.134370,251.014402,254.633730,256.446220,257.404996,260.779021,262.847840,264.650788,265.575190,267.312681,270.106661,270.977518,273.318964,274.849125,276.643089,278.169761,279.469851,281.461723,282.456164,284.104524,286.089500,287.554029,289.323975,290.550286,292.329420,293.530878,295.034266,296.927215,297.851685,299.823289,301.013838,302.456009,303.726029,304.882105,306.827468,307.793553,309.269966,310.811865,312.093403,313.190417,314.879889,315.826038,317.327726,318.823749,319.813173,321.374679,322.358713,323.840879,325.279543,326.319612,327.751935,328.889724,329.975469,331.351234,332.413975,333.557321,334.832932,336.038236,337.227204,338.357431,339.482937,340.701037,341.826874,343.014370,344.181759,345.352264,346.553230,347.701598,348.878990,350.082479,351.219131,352.443266,353.591808,354.776330,355.907073,357.134473,358.236889,359.454088,360.616783,361.707603,362.890532,364.044729,365.169355,366.355191,367.486832,368.657764,369.799405,370.955821,372.072803,373.229675,374.364036,375.543788,376.662048,377.813734,378.944916,380.089611,381.206493,382.348960,383.482943,384.619186,385.733898,386.886336,387.991466,389.127990,390.258652,391.373513,392.505369,393.623669,394.749805,395.872726,396.988159,398.114451,399.227890,400.347728,401.469398,402.588042,403.700197,404.821265,405.936281,407.045949,408.165166,409.275936,410.384886,411.501438,412.611083,413.723957,414.833175,415.944629,417.056010,418.159961,419.269863,420.380075,421.487485,422.593693,423.701493,424.810030,425.912088,427.018901,428.123886,429.231149,430.333959,431.438843,432.544064,433.647423,434.752192,435.857516,436.958789,438.063028,439.167603,440.270556,441.375144,442.478059,443.581655,444.686318,445.789207,446.894098,447.997042,449.100966,450.206264,451.308773,452.413213,453.517038,454.619785,455.723819,456.827426,457.929842,459.033481,460.137117,461.239532,462.342897,463.447083,464.550089,465.653213,466.756838,467.859659,468.963042,470.066634,471.169891,472.273352,473.377078,474.480571,475.584192,476.687791,477.791466,478.895066,479.998856,481.102569,482.206385,483.310106,484.413856,485.517744,486.621488,487.725245,488.829080,489.932925,491.036758,492.140621,493.244511,494.348422,495.452355,496.556313,497.660309,498.764328,499.868383,500.972453,502.076547,503.180665,504.284809,505.388981,506.493192,507.597423,508.701681,509.805976,510.910291,512.014630,513.118997,514.223395,515.327822,516.432275,517.536759,518.641273,519.745809,520.850373,521.954970,523.059592,524.164244,525.268922,526.373630,527.478363,528.583126,529.687912,530.792733,531.897574,533.002440,534.107338,535.212254,536.317201,537.422168,538.527165,539.632184,540.737231,541.842303,542.947401,544.052527,545.157678,546.262857,547.368062,548.473291,549.578551,550.683836,551.789149,552.894489,554.000017,555.105407,556.210889,557.316399,558.421937,559.527500,560.633094,561.738714,562.844363,563.950041,565.055747,566.161478,567.267240,568.373027,569.478848,570.584692,571.690566,572.796464,573.902391,575.008345,576.114329,577.220340,578.326378,579.432449,580.538544,581.644669,582.750821,583.857003,584.963212,586.069450,587.175718,588.282015,589.388340,590.494697,591.601081,592.707498,593.813942,594.920417,596.026920,597.133454,598.240018,599.346611,600.453235,601.559889,602.666574,603.773289,604.880033,605.986811,607.093616,608.200454,609.307322,610.414222,611.521152,612.628116,613.735110,614.842137,615.949195,617.056286,618.163408,619.270563,620.377750,621.484970,622.592222,623.699508,624.806826,625.914177,627.021561,628.128978,629.236430,630.343914,631.451432,632.558983,633.666569,634.774189,635.881842,636.989531,638.097253,639.205011,640.312803,641.420630,642.528491,643.636389,644.744321,645.852289,646.960293,648.068332,649.176407,650.284517,651.392664,652.500847,653.609066,654.717322,655.825614,656.933943,658.042309,659.150712,660.259153,661.367630,662.476145,663.584698,664.693289,665.801917,666.910583,668.019288,669.128031,670.236813,671.345633,672.454492,673.563390,674.672327,675.781304,676.890320,677.999376,679.108472,680.217607,681.326783,682.435999,683.545256,684.654553,685.763891,686.873270,687.982690,689.092151,690.201654,691.311198,692.420784,693.530412,694.640082,695.749794,696.859549,697.969346,699.079186,700.189069,701.298995,702.408965,703.518978,704.629035,705.739136,706.849281,707.959470,709.069704,710.179982,711.290305,712.400673,713.511086,714.621545,715.732049,716.842599,717.953194,719.063836,720.174524,721.285258,722.396039,723.506867,724.617742,725.728663,726.839632,727.950648,729.061712,730.172823,731.283982,732.395189,733.506444,734.617747,735.729099,736.840499,737.951948,739.063445,740.174992,741.286587,742.398232,743.509926,744.621670,745.733464,746.845308,747.957202,749.069146,750.181141,751.293186,752.405282,753.517429,754.629627,755.741877,756.854177,757.966530,759.078933,760.191389,761.303897,762.416456,763.529068,764.641732,765.754449,766.867218,767.980040,769.092915,770.205843,771.318824,772.431859,773.544947,774.658089,775.771284,776.884533,777.997837,779.111194,780.224606,781.338072,782.451593,783.565169,784.678799,785.792485,786.906225,788.020021,789.133873,790.247780,791.361742,792.475761,793.589835,794.703965,795.818152,796.932395,798.046694,799.161051,800.275464,801.389935,802.504462,803.619047,804.733690,805.848391,806.963149,808.077966,809.192841,810.307774,811.422766,812.537817,813.652927,814.768096,815.883325,816.998613,818.113961,819.229369,820.344838,821.460366,822.575955,823.691605,824.807316,825.923088,827.038921,828.154816,829.270772,830.386790,831.502870,832.619012,833.735217,834.851484,835.967814,837.084207,838.200662,839.317181,840.433764,841.550410,842.667120,843.783894,844.900732,846.017634,847.134601,848.251632,849.368728,850.485889,851.603115,852.720407,853.837764,854.955187,856.072676,857.190231,858.307852,859.425540,860.543294,861.661115,862.779003,863.896958,865.014980,866.133070,867.251227,868.369452,869.487745,870.606106,871.724536,872.843034,873.961600,875.080236,876.198940,877.317714,878.436558,879.555471,880.674454,881.793507,882.912630,884.031824,885.151088,886.270423,887.389829,888.509306,889.628855,890.748475,891.868167,892.987931,894.107767,895.227675,896.347656,897.467710,898.587837,899.707937,900.828211,901.948458,903.068779,904.189174,905.309643,906.430186,907.550804,908.671497,909.792265,910.913108,912.034027,913.155021,914.276092,915.397239,916.518462,917.639762,918.761139,919.882593,921.004124,922.125732,923.247418,924.369182,925.491024,926.612944,927.734943,928.857020,929.979176,931.101412,932.223726,933.346120,934.468594,935.591148,936.713782,937.836497,938.959292,940.082168,941.205125,942.328163,943.451283,944.574485,945.697768,946.821134,947.944582,949.068113,950.191727,951.315424,952.439204,953.563067,954.687014,955.811045,956.935160,958.059359,959.183643,960.308011,961.432465,962.557004,963.681628,964.806338,965.931134,967.056016,968.180985,969.306040,970.431183,971.556412,972.681729,973.807134,974.932626,976.058206,977.183875,978.309632,979.435478,980.561413,981.687437,982.813551,983.939754,985.066047,986.192431,987.318905,988.445469,989.572125,990.698872,991.825710,992.952640,994.079662,995.206776,996.333983,997.461282,998.588675,999.716161];
        
        // OEIS sequence storage
        let oeisSequence = [];
        let useOEIS = false;
        
        let primes = [];
        let pathData = [];
        let historyData = [];
        let isAnimating = false;
        let animationId = null;
        let densityGrid = null;
        
        // Hardcoded OEIS sequences for offline use
        const hardcodedSequences = {
            'A000040': [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997,1009,1013,1019,1021,1031,1033,1039,1049,1051,1061,1063,1069,1087,1091,1093,1097,1103,1109,1117,1123,1129,1151,1153,1163,1171,1181,1187,1193,1201,1213,1217,1223,1229,1231,1237,1249,1259,1277,1279,1283,1289,1291,1297,1301,1303,1307,1319,1321,1327,1361,1367,1373,1381,1399,1409,1423,1427,1429,1433,1439,1447,1451,1453,1459,1471,1481,1483,1487,1489,1493,1499,1511,1523,1531,1543,1549,1553,1559,1567,1571,1579,1583,1597,1601,1607,1609,1613,1619,1621,1627,1637,1657,1663,1667,1669,1693,1697,1699,1709,1721,1723,1733,1741,1747,1753,1759,1777,1783,1787,1789,1801,1811,1823,1831,1847,1861,1867,1871,1873,1877,1879,1889,1901,1907,1913,1931,1933,1949,1951,1973,1979,1987,1993,1997,1999,2003,2011,2017,2027,2029,2039,2053,2063,2069,2081,2083,2087,2089,2099,2111,2113,2129,2131,2137,2141,2143,2153,2161,2179,2203,2207,2213,2221,2237,2239,2243,2251,2267,2269,2273,2281,2287,2293,2297,2309,2311,2333,2339,2341,2347,2351,2357,2371,2377,2381,2383,2389,2393,2399,2411,2417,2423,2437,2441,2447,2459,2467,2473,2477,2503,2521,2531,2539,2543,2549,2551,2557,2579,2591,2593,2609,2617,2621,2633,2647,2657,2659,2663,2671,2677,2683,2687,2689,2693,2699,2707,2711,2713,2719,2729,2731,2741,2749,2767,2777,2789,2791,2797,2801,2803,2819,2833,2843,2851,2857,2861,2879,2887,2897,2903,2909,2917,2927,2939,2953,2957,2963,2969,2971,2999,3001,3011,3019,3023,3037,3041,3049,3061,3067,3079,3083,3089,3109,3119,3121,3137,3163,3167,3169,3181,3187,3191,3203,3209,3217,3221,3229,3251,3253,3257,3259,3271,3299,3301,3307,3313,3319,3323,3329,3331,3343,3347,3359,3361,3371,3373,3389,3391,3407,3413,3433,3449,3457,3461,3463,3467,3469,3491,3499,3511,3517,3527,3529,3533,3539,3541,3547,3557,3559,3571,3581,3583,3593,3607,3613,3617,3623,3631,3637,3643,3659,3671,3673,3677,3691,3697,3701,3709,3719,3727,3733,3739,3761,3767,3769,3779,3793,3797,3803,3821,3823,3833,3847,3851,3853,3863,3877,3881,3889,3907,3911,3917,3919,3923,3929,3931,3943,3947,3967,3989,4001,4003,4007,4013,4019,4021,4027,4049,4051,4057,4073,4079,4091,4093,4099,4111,4127,4129,4133,4139,4153,4157,4159,4177,4201,4211,4217,4219,4229,4231,4241,4243,4253,4259,4261,4271,4273,4283,4289,4297,4327,4337,4339,4349,4357,4363,4373,4391,4397,4409,4421,4423,4441,4447,4451,4457,4463,4481,4483,4493,4507,4513,4517,4519,4523,4547,4549,4561,4567,4583,4591,4597,4603,4621,4637,4639,4643,4649,4651,4657,4663,4673,4679,4691,4703,4721,4723,4729,4733,4751,4759,4783,4787,4789,4793,4799,4801,4813,4817,4831,4861,4871,4877,4889,4903,4909,4919,4931,4933,4937,4943,4951,4957,4967,4969,4973,4987,4993,4999,5003,5009,5011,5021,5023,5039,5051,5059,5077,5081,5087,5099,5101,5107,5113,5119,5147,5153,5167,5171,5179,5189,5197,5209,5227,5231,5233,5237,5261,5273,5279,5281,5297,5303,5309,5323,5333,5347,5351,5381,5387,5393,5399,5407,5413,5417,5419,5431,5437,5441,5443,5449,5471,5477,5479,5483,5501,5503,5507,5519,5521,5527,5531,5557,5563,5569,5573,5581,5591,5623,5639,5641,5647,5651,5653,5657,5659,5669,5683,5689,5693,5701,5711,5717,5737,5741,5743,5749,5779,5783,5791,5801,5807,5813,5821,5827,5839,5843,5849,5851,5857,5861,5867,5869,5879,5881,5897,5903,5923,5927,5939,5953,5981,5987,6007,6011,6029,6037,6043,6047,6053,6067,6073,6079,6089,6091,6101,6113,6121,6131,6133,6143,6151,6163,6173,6197,6199,6203,6211,6217,6221,6229,6247,6257,6263,6269,6271,6277,6287,6299,6301,6311,6317,6323,6329,6337,6343,6353,6359,6361,6367,6373,6379,6389,6397,6421,6427,6449,6451,6469,6473,6481,6491,6521,6529,6547,6551,6553,6563,6569,6571,6577,6581,6599,6607,6619,6637,6653,6659,6661,6673,6679,6689,6691,6701,6703,6709,6719,6733,6737,6761,6763,6779,6781,6791,6793,6803,6823,6827,6829,6833,6841,6857,6863,6869,6871,6883,6899,6907,6911,6917,6947,6949,6959,6961,6967,6971,6977,6983,6991,6997,7001,7013,7019,7027,7039,7043,7057,7069,7079,7103,7109,7121,7127,7129,7151,7159,7177,7187,7193,7207,7211,7213,7219,7229,7237,7243,7247,7253,7283,7297,7307,7309,7321,7331,7333,7349,7351,7369,7393,7411,7417,7433,7451,7457,7459,7477,7481,7487,7489,7499,7507,7517,7523,7529,7537,7541,7547,7549,7559,7561,7573,7577,7583,7589,7591,7603,7607,7621,7639,7643,7649,7669,7673,7681,7687,7691,7699,7703,7717,7723,7727,7741,7753,7757,7759,7789,7793,7817,7823,7829,7841,7853,7867,7873,7877,7879,7883,7901,7907,7919],
            'A001359': [3,5,11,17,29,41,59,71,101,107,137,149,179,191,197,227,239,269,281,311,347,419,431,461,521,569,599,617,641,659,809,821,827,857,881,1019,1031,1049,1061,1091,1151,1229,1277,1289,1301,1319,1427,1451,1481,1487,1607,1619,1667,1697,1721,1787,1871,1877,1931,1949,1997,2027,2081,2087,2111,2129,2141,2237,2267,2309,2339,2381,2549,2591,2657,2687,2711,2729,2789,2801,2969,2999,3119,3167,3251,3257,3299,3329,3359,3371,3389,3461,3467,3527,3539,3557,3581,3671,3767,3821,3851,3917,3929,4001,4019,4049,4091,4127,4157,4217,4229,4241,4259,4271,4337,4421,4481,4517,4547,4637,4649,4721,4787,4799,4931,4967,5009,5021,5099,5231,5279,5417,5441,5477,5501,5519,5639,5651,5657,5741,5849,5867,5879,6089,6131,6197,6269,6299,6359,6449,6551,6569,6659,6689,6701,6761,6779,6791,6827,6869,6947,6959,7127,7211,7307,7331,7349,7457,7487,7547,7559,7589,7757,7877,7949,8009,8087,8219,8231,8291,8387,8429,8537,8597,8627,8819,8837,8861,8969,8999,9011,9041,9239,9281,9341,9419,9431,9437,9461,9629],
            'A006512': [5,7,13,19,31,43,61,73,103,109,139,151,181,193,199,229,241,271,283,313,349,421,433,463,523,571,601,619,643,661,811,823,829,859,883,1021,1033,1051,1063,1093,1153,1231,1279,1291,1303,1321,1429,1453,1483,1489,1609,1621,1669,1699,1723,1789,1873,1879,1933,1951,1999,2029,2083,2089,2113,2131,2143,2239,2269,2311,2341,2383,2551,2593,2659,2689,2713,2731,2791,2803,2971,3001,3121,3169,3253,3259,3301,3331,3361,3373,3391,3463,3469,3529,3541,3559,3583,3673,3769,3823,3853,3919,3931,4003,4021,4051,4093,4129,4159,4219,4231,4243,4261,4273,4339,4423,4483,4519,4549,4639,4651,4723,4789,4801,4933,4969,5011,5023,5101,5233,5281,5419,5443,5479,5503,5521,5641,5653,5659,5743,5851,5869,5881,6091,6133,6199,6271,6301,6361,6451,6553,6571,6661,6691,6703,6763,6781,6793,6829,6871,6949,6961,7129,7213,7309,7333,7351,7459,7489,7549,7561,7591,7759,7879,7951,8011,8089,8221,8233,8293,8389,8431,8539,8599,8629,8821,8839,8863,8971,9001,9013,9043,9241,9283,9343,9421,9433,9439,9463,9631],
            'A000668': [3,7,31,127,8191,131071,524287,2147483647],
            'A019434': [3,5,17,257,65537],
            'A000045': [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17711,28657,46368,75025,121393,196418,317811,514229,832040,1346269,2178309,3524578,5702887,9227465,14930352,24157817,39088169,63245986,102334155,165580141,267914296,433494437,701408733,1134903170,1836311903,2971215073,4807526976,7778742049,12586269025,20365011074,32951280099,53316291173,86267571272,139583862445,225851433717,365435296162,591286729879,956722026041,1548008755920,2504730781961,4052739537881,6557470319842,10610209857723,17167680177565,27777890035288,44945570212853,72723460248141,117669030460994,190392490709135,308061521170129,498454011879264,806515533049393,1304969544928657,2111485077978050,3416454622906707,5527939700884757,8944394323791464,14472334024676221,23416728348467685,37889062373143906,61305790721611591,99194853094755497,160500643816367088,259695496911122585,420196140727489673,679891637638612258,1100087778366101931,1779979416004714189,2880067194370816120,4660046610375530309,7540113804746346429,12200160415121876738,19740274219868223167,31940434634990099905,51680708854858323072,83621143489848422977,135301852344706746049,218922995834555169026,354224848179261915075],
            'A000032': [2,1,3,4,7,11,18,29,47,76,123,199,322,521,843,1364,2207,3571,5778,9349,15127,24476,39603,64079,103682,167761,271443,439204,710647,1149851,1860498,3010349,4870847,7881196,12752043,20633239,33385282,54018521,87403803,141422324,228826127,370248451,599074578,969323029,1568397607,2537720636,4106118243,6643838879,10749957122,17393796001,28143753123,45537549124,73681302247,119218851371,192900153618,312119004989,505019158607,817138163596,1322157322203,2139295485799,3461452808002,5600748293801,9062201101803,14662949395604,23725150497407,38388099893011,62113250390418,100501350283429,162614600673847,263115950957276,425730551631123,688846502588399,1114577054219522,1803423556807921,2918000611027443,4721424167835364,7639424778862807,12360848946698171,20000273725560978,32361122672259149,52361396397820127,84722519070079276,137083915467899403,221806434537978679,358890350005878082,580696784543856761,939587134549734843,1520283919093591604,2459871053643326447,3980154972736918051,6440026026380244498,10420180999117162549,16860207025497407047,27280388024614569596,44140595050111976643,71420983074726546239,115561578124838522882,186982561199565069121,302544139324403592003,489526700523968661124],
            'A001519': [1,2,5,13,34,89,233,610,1597,4181,10946,28657,75025,196418,514229,1346269,3524578,9227465,24157817,63245986,165580141,433494437,1134903170,2971215073,7778742049,20365011074,53316291173,139583862445,365435296162,956722026041,2504730781961,6557470319842,17167680177565,44945570212853,117669030460994,308061521170129,806515533049393,2111485077978050,5527939700884757,14472334024676221,37889062373143906,99194853094755497,259695496911122585,679891637638612258,1779979416004714189,4660046610375530309,12200160415121876738,31940434634990099905,83621143489848422977,218922995834555169026],
            'A000079': [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,262144,524288,1048576,2097152,4194304,8388608,16777216,33554432,67108864,134217728,268435456,536870912,1073741824,2147483648,4294967296,8589934592,17179869184,34359738368,68719476736,137438953472,274877906944,549755813888,1099511627776,2199023255552,4398046511104,8796093022208,17592186044416,35184372088832,70368744177664,140737488355328,281474976710656,562949953421312,1125899906842624,2251799813685248,4503599627370496,9007199254740992,18014398509481984,36028797018963968,72057594037927936,144115188075855872,288230376151711744,576460752303423488,1152921504606846976,2305843009213693952,4611686018427387904,9223372036854775808],
            'A000244': [1,3,9,27,81,243,729,2187,6561,19683,59049,177147,531441,1594323,4782969,14348907,43046721,129140163,387420489,1162261467,3486784401,10460353203,31381059609,94143178827,282429536481,847288609443,2541865828329,7625597484987,22876792454961,68630377364883,205891132094649,617673396283947,1853020188851841,5559060566555523,16677181699666569,50031545098999707,150094635296999121,450283905890997363,1350851717672992089,4052555153018976267,12157665459056928801,36472996377170786403,109418989131512359209,328256967394537077627,984770902183611232881,2954312706550833698643,8862938119652501095929,26588814358957503287787,79766443076872509863361,239299329230617529590083],
            'A000290': [0,1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,484,529,576,625,676,729,784,841,900,961,1024,1089,1156,1225,1296,1369,1444,1521,1600,1681,1764,1849,1936,2025,2116,2209,2304,2401,2500,2601,2704,2809,2916,3025,3136,3249,3364,3481,3600,3721,3844,3969,4096,4225,4356,4489,4624,4761,4900,5041,5184,5329,5476,5625,5776,5929,6084,6241,6400,6561,6724,6889,7056,7225,7396,7569,7744,7921,8100,8281,8464,8649,8836,9025,9216,9409,9604,9801],
            'A000578': [0,1,8,27,64,125,216,343,512,729,1000,1331,1728,2197,2744,3375,4096,4913,5832,6859,8000,9261,10648,12167,13824,15625,17576,19683,21952,24389,27000,29791,32768,35937,39304,42875,46656,50653,54872,59319,64000,68921,74088,79507,85184,91125,97336,103823,110592,117649,125000,132651,140608,148877,157464,166375,175616,185193,195112,205379,216000,226981,238328,250047,262144,274625,287496,300763,314432,328509,343000,357911,373248,389017,405224,421875,438976,456533,474552,493039,512000,531441,551368,571787,592704,614125,636056,658503,681472,704969,729000,753571,778688,804357,830584,857375,884736,912673,941192,970299],
            'A000217': [0,1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,276,300,325,351,378,406,435,465,496,528,561,595,630,666,703,741,780,820,861,903,946,990,1035,1081,1128,1176,1225,1275,1326,1378,1431,1485,1540,1596,1653,1711,1770,1830,1891,1953,2016,2080,2145,2211,2278,2346,2415,2485,2556,2628,2701,2775,2850,2926,3003,3081,3160,3240,3321,3403,3486,3570,3655,3741,3828,3916,4005,4095,4186,4278,4371,4465,4560,4656,4753,4851,4950],
            'A000326': [0,1,5,12,22,35,51,70,92,117,145,176,210,247,287,330,376,425,477,532,590,651,715,782,852,925,1001,1080,1162,1247,1335,1426,1520,1617,1717,1820,1926,2035,2147,2262,2380,2501,2625,2752,2882,3015,3151,3290,3432,3577,3725,3876,4030,4187,4347,4510,4676,4845,5017,5192,5370,5551,5735,5922,6112,6305,6501,6700,6902,7107,7315,7526,7740,7957,8177,8400,8626,8855,9087,9322,9560,9801,10045,10292,10542,10795,11051,11310,11572,11837,12105,12376,12650,12927,13207,13490,13776,14065,14357,14652],
            'A000384': [0,1,6,15,28,45,66,91,120,153,190,231,276,325,378,435,496,561,630,703,780,861,946,1035,1128,1225,1326,1431,1540,1653,1770,1891,2016,2145,2278,2415,2556,2701,2850,3003,3160,3321,3486,3655,3828,4005,4186,4371,4560,4753,4950,5151,5356,5565,5778,5995,6216,6441,6670,6903,7140,7381,7626,7875,8128,8385,8646,8911,9180,9453,9730,10011,10296,10585,10878,11175,11476,11781,12090,12403,12720,13041,13366,13695,14028,14365,14706,15051,15400,15753,16110,16471,16836,17205,17578,17955,18336,18721,19110,19503],
            'A000142': [1,1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800,87178291200,1307674368000,20922789888000,355687428096000,6402373705728000,121645100408832000,2432902008176640000],
            'A000108': [1,1,2,5,14,42,132,429,1430,4862,16796,58786,208012,742900,2674440,9694845,35357670,129644790,477638700,1767263190,6564120420,24466267020,91482563640,343059613650,1289904147324,4861946401452,18367353072152,69533550916004,263747951750360,1002242216651368,3814986502092304],
            'A000984': [1,2,6,20,70,252,924,3432,12870,48620,184756,705432,2704156,10400600,40116600,155117520,601080390,2333606220,9075135300,35345263800,137846528820,538257874440,2104098963720,8233430727600,32247603683100,126410606437752,495918532948104,1946939425648112,7648690600760440,30067266499541040,118264581564861424],
        };
        
        const colorSchemes = {
            fire: [
                {pos: 0, r: 0, g: 0, b: 0},
                {pos: 0.33, r: 139, g: 0, b: 0},
                {pos: 0.66, r: 255, g: 69, b: 0},
                {pos: 0.85, r: 255, g: 165, b: 0},
                {pos: 1, r: 255, g: 255, b: 100}
            ],
            plasma: [
                {pos: 0, r: 13, g: 8, b: 135},
                {pos: 0.25, r: 126, g: 3, b: 168},
                {pos: 0.5, r: 204, g: 71, b: 120},
                {pos: 0.75, r: 248, g: 149, b: 64},
                {pos: 1, r: 240, g: 249, b: 33}
            ],
            viridis: [
                {pos: 0, r: 68, g: 1, b: 84},
                {pos: 0.25, r: 59, g: 82, b: 139},
                {pos: 0.5, r: 33, g: 145, b: 140},
                {pos: 0.75, r: 94, g: 201, b: 98},
                {pos: 1, r: 253, g: 231, b: 37}
            ],
            cool: [
                {pos: 0, r: 0, g: 255, b: 255},
                {pos: 0.5, r: 100, g: 100, b: 255},
                {pos: 1, r: 255, g: 0, b: 255}
            ],
            thermal: [
                {pos: 0, r: 0, g: 0, b: 0},
                {pos: 0.33, r: 139, g: 0, b: 0},
                {pos: 0.66, r: 255, g: 140, b: 0},
                {pos: 0.9, r: 255, g: 255, b: 0},
                {pos: 1, r: 255, g: 255, b: 255}
            ]
        };
        
        function getColorFromScheme(scheme, t) {
            if (!colorSchemes[scheme]) return {r: 100, g: 200, b: 255};
            
            const colors = colorSchemes[scheme];
            t = Math.max(0, Math.min(1, t));
            
            for (let i = 0; i < colors.length - 1; i++) {
                if (t >= colors[i].pos && t <= colors[i + 1].pos) {
                    const localT = (t - colors[i].pos) / (colors[i + 1].pos - colors[i].pos);
                    return {
                        r: Math.round(colors[i].r + (colors[i + 1].r - colors[i].r) * localT),
                        g: Math.round(colors[i].g + (colors[i + 1].g - colors[i].g) * localT),
                        b: Math.round(colors[i].b + (colors[i + 1].b - colors[i].b) * localT)
                    };
                }
            }
            return colors[colors.length - 1];
        }
        
        // Zoom and pan state for each canvas
        const canvasStates = {
            main: { zoom: 1, offsetX: 0, offsetY: 0, isDragging: false, lastX: 0, lastY: 0 },
            phase: { zoom: 1, offsetX: 0, offsetY: 0, isDragging: false, lastX: 0, lastY: 0 },
            history: { zoom: 1, offsetX: 0, offsetY: 0, isDragging: false, lastX: 0, lastY: 0 }
        };
        
        function scanForZeros() {
            const start = parseFloat(document.getElementById('scanStart').value);
            const end = parseFloat(document.getElementById('scanEnd').value);
            const resolution = parseFloat(document.getElementById('scanResolution').value);
            const statusEl = document.getElementById('zeroScanStatus');
            const resultsEl = document.getElementById('zeroResults');
            const listEl = document.getElementById('zeroList');
            
            if (isNaN(start) || isNaN(end) || start >= end) {
                statusEl.textContent = 'Invalid range. Start must be less than end.';
                statusEl.style.color = '#ff6464';
                return;
            }
            
            statusEl.textContent = 'Scanning for zeros...';
            statusEl.style.color = '#ffd700';
            resultsEl.style.display = 'none';
            
            const potentialZeros = [];
            let minMagnitude = Infinity;
            let minT = start;
            
            // Store current parameters
            const origT = parseFloat(document.getElementById('criticalT').value);
            
            // Scan through range
            for (let t = start; t <= end; t += resolution) {
                document.getElementById('criticalT').value = t;
                compute();
                
                const magnitude = parseFloat(document.getElementById('statMagnitude').textContent);
                
                if (magnitude < minMagnitude) {
                    minMagnitude = magnitude;
                    minT = t;
                }
                
                // Look for local minima (potential zeros)
                if (magnitude < 0.01) {
                    potentialZeros.push({t: t.toFixed(6), magnitude: magnitude.toFixed(8)});
                }
            }
            
            // Restore original t
            document.getElementById('criticalT').value = origT;
            compute();
            
            if (potentialZeros.length > 0) {
                statusEl.textContent = `Found ${potentialZeros.length} potential zero(s)`;
                statusEl.style.color = '#64ff64';
                resultsEl.style.display = 'block';
                
                listEl.innerHTML = '';
                potentialZeros.forEach(z => {
                    const btn = document.createElement('button');
                    btn.className = 'zero-btn';
                    btn.textContent = `t ≈ ${z.t} (|P| = ${z.magnitude})`;
                    btn.onclick = () => {
                        document.getElementById('criticalT').value = z.t;
                        document.getElementById('tValue').textContent = parseFloat(z.t).toFixed(4);
                        compute();
                    };
                    listEl.appendChild(btn);
                });
            } else {
                statusEl.textContent = `No strong zeros found. Minimum at t ≈ ${minT.toFixed(4)} (|P| = ${minMagnitude.toFixed(6)})`;
                statusEl.style.color = '#ffaa00';
                resultsEl.style.display = 'none';
            }
        }
        
        function scanForZeros() {
            const start = parseFloat(document.getElementById('scanStart').value);
            const end = parseFloat(document.getElementById('scanEnd').value);
            const resolution = parseFloat(document.getElementById('scanResolution').value);
            const statusEl = document.getElementById('zeroScanStatus');
            const resultsEl = document.getElementById('zeroResults');
            const listEl = document.getElementById('zeroList');
            
            if (isNaN(start) || isNaN(end) || start >= end) {
                statusEl.textContent = 'Invalid range. Start must be less than end.';
                statusEl.style.color = '#ff6464';
                return;
            }
            
            statusEl.textContent = 'Scanning for zeros...';
            statusEl.style.color = '#ffd700';
            resultsEl.style.display = 'none';
            
            const potentialZeros = [];
            let minMagnitude = Infinity;
            let minT = start;
            
            // Store current parameters
            const origT = parseFloat(document.getElementById('criticalT').value);
            
            // Scan through range
            for (let t = start; t <= end; t += resolution) {
                document.getElementById('criticalT').value = t;
                compute();
                
                const magnitude = parseFloat(document.getElementById('statMagnitude').textContent);
                
                if (magnitude < minMagnitude) {
                    minMagnitude = magnitude;
                    minT = t;
                }
                
                // Look for local minima (potential zeros)
                if (magnitude < 0.01) {
                    potentialZeros.push({t: t.toFixed(6), magnitude: magnitude.toFixed(8)});
                }
            }
            
            // Restore original t
            document.getElementById('criticalT').value = origT;
            compute();
            
            if (potentialZeros.length > 0) {
                statusEl.textContent = `Found ${potentialZeros.length} potential zero(s)`;
                statusEl.style.color = '#64ff64';
                resultsEl.style.display = 'block';
                
                listEl.innerHTML = '';
                potentialZeros.forEach(z => {
                    const btn = document.createElement('button');
                    btn.className = 'zero-btn';
                    btn.textContent = `t ≈ ${z.t} (|P| = ${z.magnitude})`;
                    btn.onclick = () => {
                        document.getElementById('criticalT').value = z.t;
                        document.getElementById('tValue').textContent = parseFloat(z.t).toFixed(4);
                        compute();
                    };
                    listEl.appendChild(btn);
                });
            } else {
                statusEl.textContent = `No strong zeros found. Minimum at t ≈ ${minT.toFixed(4)} (|P| = ${minMagnitude.toFixed(6)})`;
                statusEl.style.color = '#ffaa00';
                resultsEl.style.display = 'none';
            }
        }
        
        function sievePrimes(max) {
            const sieve = new Array(max + 1).fill(true);
            sieve[0] = sieve[1] = false;
            for (let i = 2; i * i <= max; i++) {
                if (sieve[i]) {
                    for (let j = i * i; j <= max; j += i) sieve[j] = false;
                }
            }
            return sieve.map((v, i) => v ? i : 0).filter(x => x > 0);
        }
        
        function initZeros() {
            const list = document.getElementById('zerosList');
            riemannZeros.forEach((z, i) => {
                const btn = document.createElement('button');
                btn.className = 'zero-btn';
                btn.textContent = `Zero #${i+1}: t = ${z.toFixed(6)}`;
                btn.onclick = () => {
                    document.getElementById('criticalT').value = z;
                    document.getElementById('tValue').textContent = z.toFixed(4);
                    compute();
                };
                list.appendChild(btn);
            });
        }
        
        function updateSweepUI() {
            const sweepType = document.getElementById('sweepType').value;
            document.querySelectorAll('.sweep-config').forEach(el => el.style.display = 'none');
            document.getElementById(`sweep_${sweepType}`).style.display = 'block';
        }
        
        async function runParameterSweep() {
            const sweepType = document.getElementById('sweepType').value;
            const resolution = parseInt(document.getElementById('sweepResolution').value);
            const metric = document.getElementById('sweepMetric').value;
            const statusEl = document.getElementById('sweepStatus');
            const progressEl = document.getElementById('sweepProgress');
            const resultsEl = document.getElementById('sweepResults');
            const legendEl = document.getElementById('sweepLegend');
            
            sweepCancelled = false;
            document.getElementById('cancelSweepBtn').style.display = 'block';
            
            statusEl.textContent = 'Initializing sweep...';
            statusEl.style.color = '#ffd700';
            progressEl.style.display = 'block';
            resultsEl.style.display = 'none';
            legendEl.style.display = 'none';
            
            const startTime = performance.now();
            
            try {
                if (sweepType === 'M_t') {
                    await sweepMT(resolution, metric, startTime);
                } else if (sweepType === 'alpha_beta') {
                    await sweepAlphaBeta(resolution, metric, startTime);
                } else if (sweepType === 't_scan') {
                    await scanT(startTime);
                } else if (sweepType === 'M_scan') {
                    await scanM(startTime);
                }
            } catch (error) {
                statusEl.textContent = `Error: ${error.message}`;
                statusEl.style.color = '#ff6464';
            }
            
            document.getElementById('cancelSweepBtn').style.display = 'none';
        }
        
        async function sweepMT(resolution, metric, startTime) {
            const M_min = parseInt(document.getElementById('M_min').value);
            const M_max = parseInt(document.getElementById('M_max').value);
            const t_min = parseFloat(document.getElementById('t_min').value);
            const t_max = parseFloat(document.getElementById('t_max').value);
            
            const M_step = (M_max - M_min) / (resolution - 1);
            const t_step = (t_max - t_min) / (resolution - 1);
            
            sweepData = {
                type: 'M_t',
                M_values: [],
                t_values: [],
                data: [],
                M_min, M_max, t_min, t_max,
                resolution, metric
            };
            
            for (let i = 0; i < resolution; i++) {
                sweepData.M_values.push(Math.round(M_min + i * M_step));
                sweepData.t_values.push(t_min + i * t_step);
                sweepData.data.push(new Array(resolution).fill(0));
            }
            
            const totalPoints = resolution * resolution;
            let computed = 0;
            
            for (let i = 0; i < resolution; i++) {
                if (sweepCancelled) break;
                
                for (let j = 0; j < resolution; j++) {
                    const M = sweepData.M_values[i];
                    const t = sweepData.t_values[j];
                    
                    // Temporarily set parameters
                    document.getElementById('modulus').value = M;
                    document.getElementById('criticalT').value = t;
                    
                    // Compute
                    compute();
                    
                    // Extract metric
                    let value = 0;
                    if (metric === 'magnitude') value = parseFloat(document.getElementById('statMagnitude').textContent);
                    else if (metric === 'coherence') value = parseFloat(document.getElementById('statCoherence').textContent);
                    else if (metric === 'real') value = parseFloat(document.getElementById('statReal').textContent);
                    else if (metric === 'imag') value = parseFloat(document.getElementById('statImag').textContent);
                    else if (metric === 'phase') value = Math.atan2(parseFloat(document.getElementById('statImag').textContent), parseFloat(document.getElementById('statReal').textContent));
                    
                    sweepData.data[i][j] = value;
                    computed++;
                    
                    // Update progress
                    const progress = (computed / totalPoints * 100).toFixed(1);
                    document.getElementById('sweepProgressBar').style.width = progress + '%';
                    document.getElementById('sweepProgressText').textContent = `${computed} / ${totalPoints} points computed`;
                    
                    if (computed % 10 === 0) {
                        await new Promise(resolve => setTimeout(resolve, 0)); // Allow UI update
                    }
                }
            }
            
            if (!sweepCancelled) {
                finalizeSweep(startTime);
            }
        }
        
        async function sweepAlphaBeta(resolution, metric, startTime) {
            const alpha_min = parseFloat(document.getElementById('alpha_min').value);
            const alpha_max = parseFloat(document.getElementById('alpha_max').value);
            const beta_min = parseFloat(document.getElementById('beta_min').value);
            const beta_max = parseFloat(document.getElementById('beta_max').value);
            
            const alpha_step = (alpha_max - alpha_min) / (resolution - 1);
            const beta_step = (beta_max - beta_min) / (resolution - 1);
            
            sweepData = {
                type: 'alpha_beta',
                alpha_values: [],
                beta_values: [],
                data: [],
                alpha_min, alpha_max, beta_min, beta_max,
                resolution, metric
            };
            
            for (let i = 0; i < resolution; i++) {
                sweepData.alpha_values.push(alpha_min + i * alpha_step);
                sweepData.beta_values.push(beta_min + i * beta_step);
                sweepData.data.push(new Array(resolution).fill(0));
            }
            
            const totalPoints = resolution * resolution;
            let computed = 0;
            
            for (let i = 0; i < resolution; i++) {
                if (sweepCancelled) break;
                
                for (let j = 0; j < resolution; j++) {
                    const alpha = sweepData.alpha_values[i];
                    const beta = sweepData.beta_values[j];
                    
                    document.getElementById('alpha').value = alpha;
                    document.getElementById('beta').value = beta;
                    
                    compute();
                    
                    let value = 0;
                    if (metric === 'magnitude') value = parseFloat(document.getElementById('statMagnitude').textContent);
                    else if (metric === 'coherence') value = parseFloat(document.getElementById('statCoherence').textContent);
                    else if (metric === 'real') value = parseFloat(document.getElementById('statReal').textContent);
                    else if (metric === 'imag') value = parseFloat(document.getElementById('statImag').textContent);
                    
                    sweepData.data[i][j] = value;
                    computed++;
                    
                    const progress = (computed / totalPoints * 100).toFixed(1);
                    document.getElementById('sweepProgressBar').style.width = progress + '%';
                    document.getElementById('sweepProgressText').textContent = `${computed} / ${totalPoints} points computed`;
                    
                    if (computed % 10 === 0) {
                        await new Promise(resolve => setTimeout(resolve, 0));
                    }
                }
            }
            
            if (!sweepCancelled) {
                finalizeSweep(startTime);
            }
        }
        
        async function scanT(startTime) {
            const t_min = parseFloat(document.getElementById('tscan_min').value);
            const t_max = parseFloat(document.getElementById('tscan_max').value);
            const step = parseFloat(document.getElementById('tscan_step').value);
            const threshold = parseFloat(document.getElementById('tscan_threshold').value);
            
            sweepData = {
                type: 't_scan',
                values: [],
                t_min, t_max, step, threshold
            };
            
            const totalPoints = Math.floor((t_max - t_min) / step);
            let computed = 0;
            const detectedZeros = [];
            
            for (let t = t_min; t <= t_max; t += step) {
                if (sweepCancelled) break;
                
                document.getElementById('criticalT').value = t;
                compute();
                
                const magnitude = parseFloat(document.getElementById('statMagnitude').textContent);
                sweepData.values.push({ t, magnitude });
                
                if (magnitude < threshold) {
                    detectedZeros.push({ t: t.toFixed(4), magnitude: magnitude.toFixed(8) });
                }
                
                computed++;
                const progress = (computed / totalPoints * 100).toFixed(1);
                document.getElementById('sweepProgressBar').style.width = progress + '%';
                document.getElementById('sweepProgressText').textContent = `${computed} / ${totalPoints} points scanned`;
                
                if (computed % 10 === 0) {
                    await new Promise(resolve => setTimeout(resolve, 0));
                }
            }
            
            sweepData.detectedZeros = detectedZeros;
            
            if (!sweepCancelled) {
                finalizeScan(startTime, detectedZeros);
            }
        }
        
        async function scanM(startTime) {
            const M_min = parseInt(document.getElementById('Mscan_min').value);
            const M_max = parseInt(document.getElementById('Mscan_max').value);
            const step = parseInt(document.getElementById('Mscan_step').value);
            
            sweepData = {
                type: 'M_scan',
                values: [],
                M_min, M_max, step
            };
            
            const totalPoints = Math.floor((M_max - M_min) / step);
            let computed = 0;
            const resonances = [];
            
            for (let M = M_min; M <= M_max; M += step) {
                if (sweepCancelled) break;
                
                document.getElementById('modulus').value = M;
                compute();
                
                const magnitude = parseFloat(document.getElementById('statMagnitude').textContent);
                sweepData.values.push({ M, magnitude });
                
                if (magnitude > 2.0) {
                    resonances.push({ M, magnitude: magnitude.toFixed(6) });
                }
                
                computed++;
                const progress = (computed / totalPoints * 100).toFixed(1);
                document.getElementById('sweepProgressBar').style.width = progress + '%';
                document.getElementById('sweepProgressText').textContent = `${computed} / ${totalPoints} moduli scanned`;
                
                if (computed % 10 === 0) {
                    await new Promise(resolve => setTimeout(resolve, 0));
                }
            }
            
            sweepData.resonances = resonances;
            
            if (!sweepCancelled) {
                finalizeScan(startTime, resonances);
            }
        }
        
        function finalizeSweep(startTime) {
            const endTime = performance.now();
            const duration = ((endTime - startTime) / 1000).toFixed(2);
            
            // Find min/max
            let minVal = Infinity, maxVal = -Infinity;
            sweepData.data.forEach(row => {
                row.forEach(val => {
                    minVal = Math.min(minVal, val);
                    maxVal = Math.max(maxVal, val);
                });
            });
            
            document.getElementById('sweepTime').textContent = duration + 's';
            document.getElementById('sweepPoints').textContent = sweepData.resolution * sweepData.resolution;
            document.getElementById('sweepMin').textContent = minVal.toFixed(6);
            document.getElementById('sweepMax').textContent = maxVal.toFixed(6);
            
            document.getElementById('legendMin').textContent = minVal.toFixed(3);
            document.getElementById('legendMax').textContent = maxVal.toFixed(3);
            
            document.getElementById('sweepStatus').textContent = '✓ Sweep complete';
            document.getElementById('sweepStatus').style.color = '#64ff64';
            document.getElementById('sweepResults').style.display = 'block';
            document.getElementById('sweepLegend').style.display = 'block';
            
            drawSweepHeatmap();
        }
        
        function finalizeScan(startTime, features) {
            const endTime = performance.now();
            const duration = ((endTime - startTime) / 1000).toFixed(2);
            
            document.getElementById('sweepTime').textContent = duration + 's';
            document.getElementById('sweepPoints').textContent = sweepData.values.length;
            
            const magnitudes = sweepData.values.map(v => v.magnitude || v.M);
            const minVal = Math.min(...magnitudes);
            const maxVal = Math.max(...magnitudes);
            
            document.getElementById('sweepMin').textContent = minVal.toFixed(6);
            document.getElementById('sweepMax').textContent = maxVal.toFixed(6);
            
            document.getElementById('sweepStatus').textContent = `✓ Scan complete: ${features.length} features detected`;
            document.getElementById('sweepStatus').style.color = '#64ff64';
            document.getElementById('sweepResults').style.display = 'block';
            
            displayDetectedFeatures(features);
            drawScanChart();
        }
        
        function drawSweepHeatmap() {
            const canvas = document.getElementById('sweepCanvas');
            const ctx = canvas.getContext('2d');
            const w = canvas.width, h = canvas.height;
            
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, w, h);
            
            const padding = { left: 80, right: 120, top: 60, bottom: 80 };
            const heatW = w - padding.left - padding.right;
            const heatH = h - padding.top - padding.bottom;
            
            const resolution = sweepData.resolution;
            const cellW = heatW / resolution;
            const cellH = heatH / resolution;
            
            let minVal = Infinity, maxVal = -Infinity;
            sweepData.data.forEach(row => {
                row.forEach(val => {
                    minVal = Math.min(minVal, val);
                    maxVal = Math.max(maxVal, val);
                });
            });
            
            const range = maxVal - minVal;
            
            // Draw heatmap
            for (let i = 0; i < resolution; i++) {
                for (let j = 0; j < resolution; j++) {
                    const val = sweepData.data[i][j];
                    const t = (val - minVal) / range;
                    
                    const color = getColorFromScheme('fire', t);
                    ctx.fillStyle = `rgb(${color.r}, ${color.g}, ${color.b})`;
                    ctx.fillRect(
                        padding.left + i * cellW,
                        padding.top + j * cellH,
                        cellW + 1,
                        cellH + 1
                    );
                }
            }
            
            // Draw axes
            ctx.strokeStyle = '#ffd700';
            ctx.lineWidth = 2;
            ctx.strokeRect(padding.left, padding.top, heatW, heatH);
            
            // Labels
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 16px sans-serif';
            ctx.textAlign = 'center';
            
            if (sweepData.type === 'M_t') {
                ctx.fillText('Modulus M vs Height t Heatmap', w / 2, 30);
                ctx.fillText('M', w / 2, h - 20);
                ctx.save();
                ctx.translate(20, h / 2);
                ctx.rotate(-Math.PI / 2);
                ctx.fillText('t', 0, 0);
                ctx.restore();
                
                // Tick labels
                ctx.font = '12px monospace';
                ctx.fillStyle = '#aaa';
                for (let i = 0; i <= 4; i++) {
                    const M = sweepData.M_values[Math.floor(i * (resolution - 1) / 4)];
                    const t = sweepData.t_values[Math.floor(i * (resolution - 1) / 4)];
                    ctx.fillText(M, padding.left + (heatW / 4) * i, h - padding.bottom + 20);
                    ctx.textAlign = 'right';
                    ctx.fillText(t.toFixed(1), padding.left - 10, padding.top + (heatH / 4) * i);
                    ctx.textAlign = 'center';
                }
            } else if (sweepData.type === 'alpha_beta') {
                ctx.fillText('Alpha α vs Beta β Heatmap', w / 2, 30);
                ctx.fillText('α', w / 2, h - 20);
                ctx.save();
                ctx.translate(20, h / 2);
                ctx.rotate(-Math.PI / 2);
                ctx.fillText('β', 0, 0);
                ctx.restore();
            }
        }
        
        function drawScanChart() {
            const canvas = document.getElementById('sweepCanvas');
            const ctx = canvas.getContext('2d');
            const w = canvas.width, h = canvas.height;
            
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, w, h);
            
            const padding = { left: 80, right: 40, top: 60, bottom: 80 };
            const chartW = w - padding.left - padding.right;
            const chartH = h - padding.top - padding.bottom;
            
            const values = sweepData.values;
            const magnitudes = values.map(v => v.magnitude);
            const minY = Math.min(...magnitudes);
            const maxY = Math.max(...magnitudes);
            const rangeY = maxY - minY;
            
            // Draw grid
            ctx.strokeStyle = '#2a2a4a';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 5; i++) {
                const y = padding.top + (chartH / 5) * i;
                ctx.beginPath();
                ctx.moveTo(padding.left, y);
                ctx.lineTo(w - padding.right, y);
                ctx.stroke();
            }
            
            // Draw line
            ctx.strokeStyle = '#ffd700';
            ctx.lineWidth = 2;
            ctx.beginPath();
            values.forEach((point, i) => {
                const x = padding.left + (i / (values.length - 1)) * chartW;
                const y = padding.top + chartH - ((point.magnitude - minY) / rangeY) * chartH;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            });
            ctx.stroke();
            
            // Labels
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 16px sans-serif';
            ctx.textAlign = 'center';
            
            if (sweepData.type === 't_scan') {
                ctx.fillText('t-Parameter Scan for Zero Detection', w / 2, 30);
                ctx.fillText('Height t', w / 2, h - 20);
            } else if (sweepData.type === 'M_scan') {
                ctx.fillText('Modulus Scan for Resonance Detection', w / 2, 30);
                ctx.fillText('Modulus M', w / 2, h - 20);
            }
            
            ctx.save();
            ctx.translate(20, h / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('Magnitude |P_t|', 0, 0);
            ctx.restore();
        }
        
        function displayDetectedFeatures(features) {
            const featuresEl = document.getElementById('detectedFeatures');
            const listEl = document.getElementById('featuresList');
            
            if (!featuresEl || !listEl) return;
            
            if (features.length === 0) {
                featuresEl.style.display = 'none';
                return;
            }
            
            featuresEl.style.display = 'block';
            
            let html = '<div style="font-family: monospace; font-size: 0.9rem; line-height: 1.8;">';
            features.forEach((f, i) => {
                if (sweepData.type === 't_scan') {
                    html += `<div style="padding: 6px; background: ${i % 2 === 0 ? '#12121a' : 'transparent'};">t = ${f.t} → |P| = ${f.magnitude}</div>`;
                } else if (sweepData.type === 'M_scan') {
                    html += `<div style="padding: 6px; background: ${i % 2 === 0 ? '#12121a' : 'transparent'};">M = ${f.M} → |P| = ${f.magnitude}</div>`;
                }
            });
            html += '</div>';
            
            listEl.innerHTML = html;
        }
        
        function cancelSweep() {
            sweepCancelled = true;
            document.getElementById('sweepStatus').textContent = 'Sweep cancelled by user';
            document.getElementById('sweepStatus').style.color = '#ff6464';
            document.getElementById('cancelSweepBtn').style.display = 'none';
        }
        
        function exportSweepPNG() {
            if (!sweepData) return;
            
            const canvas = document.getElementById('sweepCanvas');
            const link = document.createElement('a');
            link.download = `parameter_sweep_${sweepData.type}_${Date.now()}.png`;
            link.href = canvas.toDataURL('image/png');
            link.click();
        }
        
        function exportSweepCSV() {
            if (!sweepData) return;
            
            let csv = 'Parameter Sweep Data Export\n';
            csv += `Type,${sweepData.type}\n`;
            csv += `Metric,${sweepData.metric || 'N/A'}\n`;
            csv += `Timestamp,${new Date().toISOString()}\n\n`;
            
            if (sweepData.type === 'M_t' || sweepData.type === 'alpha_beta') {
                const xLabel = sweepData.type === 'M_t' ? 'M' : 'alpha';
                const yLabel = sweepData.type === 'M_t' ? 't' : 'beta';
                const xValues = sweepData.type === 'M_t' ? sweepData.M_values : sweepData.alpha_values;
                const yValues = sweepData.type === 'M_t' ? sweepData.t_values : sweepData.beta_values;
                
                csv += `${xLabel},${yLabel},${sweepData.metric}\n`;
                for (let i = 0; i < sweepData.resolution; i++) {
                    for (let j = 0; j < sweepData.resolution; j++) {
                        csv += `${xValues[i]},${yValues[j]},${sweepData.data[i][j]}\n`;
                    }
                }
            } else {
                const xLabel = sweepData.type === 't_scan' ? 't' : 'M';
                csv += `${xLabel},magnitude\n`;
                sweepData.values.forEach(v => {
                    csv += `${v.t || v.M},${v.magnitude}\n`;
                });
            }
            
            const blob = new Blob([csv], { type: 'text/csv' });
            const link = document.createElement('a');
            link.download = `sweep_data_${sweepData.type}_${Date.now()}.csv`;
            link.href = URL.createObjectURL(blob);
            link.click();
        }
        
        function runGapAnalysis() {
            const maxPrime = parseInt(document.getElementById('gapTestMax').value);
            const maxGap = parseInt(document.getElementById('gapTestMaxGap').value);
            const statusEl = document.getElementById('gapAnalysisStatus');
            const resultsEl = document.getElementById('gapResults');
            
            statusEl.textContent = 'Computing prime gaps and products...';
            statusEl.style.color = '#ffd700';
            resultsEl.style.display = 'none';
            
            // Generate primes up to maxPrime
            const testPrimes = sievePrimes(maxPrime);
            
            // Calculate gaps
            const gaps = [];
            const gapFamilies = {};
            
            for (let i = 0; i < testPrimes.length - 1; i++) {
                const gap = testPrimes[i + 1] - testPrimes[i];
                gaps.push(gap);
                
                if (!gapFamilies[gap]) {
                    gapFamilies[gap] = [];
                }
                gapFamilies[gap].push(testPrimes[i]);
            }
            
            // Special case: gap 0 is just prime 2
            gapFamilies[0] = [2];
            
            // Calculate products for each gap family
            const gapProducts = {};
            const evenGaps = [0];
            for (let g = 2; g <= maxGap; g += 2) {
                if (gapFamilies[g] && gapFamilies[g].length > 0) {
                    evenGaps.push(g);
                }
            }
            
            evenGaps.forEach(gap => {
                if (gapFamilies[gap]) {
                    let product = 1;
                    gapFamilies[gap].forEach(p => {
                        product *= (p * p) / (p * p - 1);
                    });
                    gapProducts[gap] = {
                        product: product,
                        count: gapFamilies[gap].length,
                        primes: gapFamilies[gap]
                    };
                }
            });
            
            // Calculate progressive product
            const progressiveProducts = [];
            let cumulative = 1;
            evenGaps.forEach(gap => {
                if (gapProducts[gap]) {
                    cumulative *= gapProducts[gap].product;
                    progressiveProducts.push({
                        gap: gap,
                        value: cumulative
                    });
                }
            });
            
            // Store results
            gapAnalysisResults = {
                maxPrime: maxPrime,
                totalPrimes: testPrimes.length,
                gapFamilies: gapFamilies,
                gapProducts: gapProducts,
                progressiveProducts: progressiveProducts,
                evenGaps: evenGaps
            };
            
            // Display results
            displayGapResults();
            
            statusEl.textContent = `✓ Analysis complete: ${testPrimes.length} primes, ${evenGaps.length} gap families`;
            statusEl.style.color = '#64ff64';
            resultsEl.style.display = 'block';
        }
        
        function displayGapResults() {
            const results = gapAnalysisResults;
            const targetZeta2 = Math.PI * Math.PI / 6;
            
            // Summary
            const finalProduct = results.progressiveProducts[results.progressiveProducts.length - 1].value;
            const error = Math.abs(finalProduct - targetZeta2) / targetZeta2 * 100;
            
            document.getElementById('gapSummary').innerHTML = `
                <div style="color: #ffd700;">Target ζ(2) = π²/6 ≈ ${targetZeta2.toFixed(8)}</div>
                <div>Computed Product: ${finalProduct.toFixed(8)}</div>
                <div>Relative Error: ${error.toFixed(4)}%</div>
                <div style="margin-top: 8px;">Total Primes Analyzed: ${results.totalPrimes}</div>
                <div>Gap Families Found: ${results.evenGaps.length}</div>
                <div>Maximum Prime: ${results.maxPrime}</div>
            `;
            
            // Gap families
            let familiesHTML = '<div style="display: grid; gap: 8px;">';
            results.evenGaps.forEach(gap => {
                const data = results.gapProducts[gap];
                if (data) {
                    const gapName = gap === 0 ? 'Gap 0 (Prime 2)' :
                                   gap === 2 ? 'Gap 2 (Twin Primes)' :
                                   gap === 4 ? 'Gap 4 (Cousin Primes)' :
                                   gap === 6 ? 'Gap 6 (Sexy Primes)' :
                                   `Gap ${gap}`;
                    
                    familiesHTML += `
                        <div style="background: #12121a; padding: 10px; border-radius: 4px; border-left: 3px solid #ffd700;">
                            <div style="color: #ffd700; font-weight: 600;">${gapName}</div>
                            <div>Count: ${data.count} primes</div>
                            <div>Product P<sub>${gap}</sub> = ${data.product.toFixed(8)}</div>
                            <div style="font-size: 0.75rem; color: #888; margin-top: 4px;">
                                First primes: ${data.primes.slice(0, 10).join(', ')}${data.primes.length > 10 ? '...' : ''}
                            </div>
                        </div>
                    `;
                }
            });
            familiesHTML += '</div>';
            document.getElementById('gapFamilies').innerHTML = familiesHTML;
            
            // Draw convergence chart
            drawConvergenceChart();
        }
        
        function drawConvergenceChart() {
            const canvas = document.getElementById('convergenceCanvas');
            const ctx = canvas.getContext('2d');
            const w = canvas.width;
            const h = canvas.height;
            const results = gapAnalysisResults;
            const targetZeta2 = Math.PI * Math.PI / 6;
            
            // Clear canvas
            ctx.fillStyle = '#0a0a10';
            ctx.fillRect(0, 0, w, h);
            
            // Calculate scales
            const padding = { left: 80, right: 40, top: 40, bottom: 60 };
            const chartWidth = w - padding.left - padding.right;
            const chartHeight = h - padding.top - padding.bottom;
            
            const maxY = Math.max(targetZeta2 * 1.1, ...results.progressiveProducts.map(p => p.value));
            const minY = 0;
            
            const xScale = chartWidth / (results.progressiveProducts.length - 1);
            const yScale = chartHeight / (maxY - minY);
            
            // Draw grid
            ctx.strokeStyle = '#2a2a4a';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 5; i++) {
                const y = padding.top + (chartHeight / 5) * i;
                ctx.beginPath();
                ctx.moveTo(padding.left, y);
                ctx.lineTo(w - padding.right, y);
                ctx.stroke();
                
                const value = maxY - (maxY - minY) * (i / 5);
                ctx.fillStyle = '#888';
                ctx.font = '12px monospace';
                ctx.textAlign = 'right';
                ctx.fillText(value.toFixed(4), padding.left - 10, y + 4);
            }
            
            // Draw target line
            const targetY = padding.top + chartHeight - (targetZeta2 - minY) * yScale;
            ctx.strokeStyle = '#ff6464';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(padding.left, targetY);
            ctx.lineTo(w - padding.right, targetY);
            ctx.stroke();
            ctx.setLineDash([]);
            
            ctx.fillStyle = '#ff6464';
            ctx.font = 'bold 12px sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText(`ζ(2) = π²/6 ≈ ${targetZeta2.toFixed(6)}`, w - padding.right - 200, targetY - 8);
            
            // Draw convergence line
            ctx.strokeStyle = '#ffd700';
            ctx.lineWidth = 3;
            ctx.beginPath();
            results.progressiveProducts.forEach((point, i) => {
                const x = padding.left + i * xScale;
                const y = padding.top + chartHeight - (point.value - minY) * yScale;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            });
            ctx.stroke();
            
            // Draw points
            ctx.fillStyle = '#ffd700';
            results.progressiveProducts.forEach((point, i) => {
                const x = padding.left + i * xScale;
                const y = padding.top + chartHeight - (point.value - minY) * yScale;
                ctx.beginPath();
                ctx.arc(x, y, 4, 0, 2 * Math.PI);
                ctx.fill();
            });
            
            // Draw x-axis labels
            ctx.fillStyle = '#aaa';
            ctx.font = '11px monospace';
            ctx.textAlign = 'center';
            results.progressiveProducts.forEach((point, i) => {
                if (i % Math.max(1, Math.floor(results.progressiveProducts.length / 10)) === 0) {
                    const x = padding.left + i * xScale;
                    ctx.fillText(`Gap ${point.gap}`, x, h - padding.bottom + 20);
                }
            });
            
            // Axis labels
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 14px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Progressive Product of Gap Families', w / 2, padding.top - 15);
            
            ctx.save();
            ctx.translate(20, h / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('Product Value', 0, 0);
            ctx.restore();
            
            ctx.fillText('Gap Family', w / 2, h - 15);
        }
        
        function exportGapCSV() {
            if (!gapAnalysisResults) return;
            
            let csv = 'Prime Gap Decomposition Analysis\n';
            csv += `Maximum Prime,${gapAnalysisResults.maxPrime}\n`;
            csv += `Total Primes,${gapAnalysisResults.totalPrimes}\n`;
            csv += `Target ζ(2),${(Math.PI * Math.PI / 6).toFixed(10)}\n\n`;
            
            csv += 'Gap,Prime Count,Product P_g,First 10 Primes\n';
            gapAnalysisResults.evenGaps.forEach(gap => {
                const data = gapAnalysisResults.gapProducts[gap];
                if (data) {
                    const firstPrimes = data.primes.slice(0, 10).join(' ');
                    csv += `${gap},${data.count},${data.product.toFixed(10)},"${firstPrimes}"\n`;
                }
            });
            
            csv += '\nProgressive Convergence\n';
            csv += 'Gap,Cumulative Product\n';
            gapAnalysisResults.progressiveProducts.forEach(p => {
                csv += `${p.gap},${p.value.toFixed(10)}\n`;
            });
            
            const blob = new Blob([csv], { type: 'text/csv' });
            const link = document.createElement('a');
            link.download = `gap_analysis_${gapAnalysisResults.maxPrime}primes.csv`;
            link.href = URL.createObjectURL(blob);
            link.click();
        }
        
        function exportGapChart() {
            if (!gapAnalysisResults) return;
            
            const canvas = document.getElementById('convergenceCanvas');
            const link = document.createElement('a');
            link.download = `gap_convergence_${gapAnalysisResults.maxPrime}primes.png`;
            link.href = canvas.toDataURL('image/png');
            link.click();
        }
        
        function exportGapReport() {
            if (!gapAnalysisResults) return;
            
            const results = gapAnalysisResults;
            const targetZeta2 = Math.PI * Math.PI / 6;
            const finalProduct = results.progressiveProducts[results.progressiveProducts.length - 1].value;
            const error = Math.abs(finalProduct - targetZeta2) / targetZeta2 * 100;
            
            let report = '═══════════════════════════════════════════════════════════════\n';
            report += '  PRIME GAP DECOMPOSITION OF ζ(2) = π²/6\n';
            report += '  By Wessen Getachew (@7dview), 2025\n';
            report += '═══════════════════════════════════════════════════════════════\n\n';
            
            report += 'THEORETICAL FOUNDATION\n';
            report += '─────────────────────────────────────────────────────────────\n';
            report += 'Using the Phase Law, ζ(2) decomposes into gap family products:\n';
            report += 'ζ(2) = ∏(gap=0) P₀ × ∏(gap=2) P₂ × ∏(gap=4) P₄ × ...\n\n';
            report += 'Where: P_g = ∏(p² / (p² - 1)) for primes in gap family g\n\n';
            
            report += 'ANALYSIS PARAMETERS\n';
            report += '─────────────────────────────────────────────────────────────\n';
            report += `Maximum Prime: ${results.maxPrime}\n`;
            report += `Total Primes: ${results.totalPrimes}\n`;
            report += `Gap Families: ${results.evenGaps.length}\n\n`;
            
            report += 'RESULTS\n';
            report += '─────────────────────────────────────────────────────────────\n';
            report += `Target ζ(2) = π²/6: ${targetZeta2.toFixed(10)}\n`;
            report += `Computed Product:   ${finalProduct.toFixed(10)}\n`;
            report += `Relative Error:     ${error.toFixed(6)}%\n\n`;
            
            report += 'GAP FAMILY PRODUCTS\n';
            report += '─────────────────────────────────────────────────────────────\n';
            results.evenGaps.forEach(gap => {
                const data = results.gapProducts[gap];
                if (data) {
                    const gapName = gap === 0 ? 'Gap 0 (Prime 2)' :
                                   gap === 2 ? 'Gap 2 (Twin Primes)' :
                                   gap === 4 ? 'Gap 4 (Cousin Primes)' :
                                   gap === 6 ? 'Gap 6 (Sexy Primes)' :
                                   `Gap ${gap}`;
                    
                    report += `\n${gapName}\n`;
                    report += `  Prime Count: ${data.count}\n`;
                    report += `  Product P_${gap}: ${data.product.toFixed(10)}\n`;
                    report += `  First Primes: ${data.primes.slice(0, 20).join(', ')}${data.primes.length > 20 ? '...' : ''}\n`;
                }
            });
            
            report += '\n\nPROGRESSIVE CONVERGENCE\n';
            report += '─────────────────────────────────────────────────────────────\n';
            results.progressiveProducts.forEach(p => {
                report += `Gap ${p.gap.toString().padStart(3)}: ${p.value.toFixed(10)}\n`;
            });
            
            report += '\n═══════════════════════════════════════════════════════════════\n';
            report += 'Generated by Prime-Phase Vector Visualization Tool\n';
            report += 'GitHub: wessengetachew.github.io\n';
            report += '═══════════════════════════════════════════════════════════════\n';
            
            const blob = new Blob([report], { type: 'text/plain' });
            const link = document.createElement('a');
            link.download = `gap_analysis_report_${results.maxPrime}primes.txt`;
            link.href = URL.createObjectURL(blob);
            link.click();
        }
        
        function saveSession() {
            const sessionName = document.getElementById('sessionName').value.trim();
            if (!sessionName) {
                alert('Please enter a session name');
                return;
            }
            
            const session = {
                name: sessionName,
                description: document.getElementById('sessionDescription').value.trim(),
                timestamp: new Date().toISOString(),
                parameters: {
                    M: document.getElementById('modulus').value,
                    t: document.getElementById('criticalT').value,
                    X: document.getElementById('primeCutoff').value,
                    alpha: document.getElementById('alpha').value,
                    beta: document.getElementById('beta').value,
                    gamma: document.getElementById('gamma').value
                },
                sequence: {
                    useOEIS: document.getElementById('useOEISToggle').checked,
                    oeisNumber: document.getElementById('oeisNumber').value,
                    uploadedName: uploadedSequenceName,
                    data: oeisSequence.length > 0 ? oeisSequence.slice(0, 1000) : []
                },
                history: historyData.slice()
            };
            
            // Save to localStorage
            const sessions = JSON.parse(localStorage.getItem('primePhaseSessions') || '[]');
            sessions.push(session);
            localStorage.setItem('primePhaseSessions', JSON.stringify(sessions));
            
            alert(`Session "${sessionName}" saved successfully!`);
            refreshSessions();
        }
        
        function loadSession(index) {
            const sessions = JSON.parse(localStorage.getItem('primePhaseSessions') || '[]');
            if (index < 0 || index >= sessions.length) return;
            
            const session = sessions[index];
            
            // Restore parameters
            document.getElementById('modulus').value = session.parameters.M;
            document.getElementById('criticalT').value = session.parameters.t;
            document.getElementById('primeCutoff').value = session.parameters.X;
            document.getElementById('alpha').value = session.parameters.alpha;
            document.getElementById('beta').value = session.parameters.beta;
            document.getElementById('gamma').value = session.parameters.gamma;
            
            // Update displays
            document.getElementById('mValue').textContent = session.parameters.M;
            document.getElementById('tValue').textContent = parseFloat(session.parameters.t).toFixed(4);
            document.getElementById('xValue').textContent = session.parameters.X;
            document.getElementById('alphaValue').textContent = parseFloat(session.parameters.alpha).toFixed(4);
            document.getElementById('betaValue').textContent = parseFloat(session.parameters.beta).toFixed(4);
            document.getElementById('gammaValue').textContent = parseFloat(session.parameters.gamma).toFixed(4);
            
            // Restore sequence
            if (session.sequence.useOEIS) {
                document.getElementById('useOEISToggle').checked = true;
                if (session.sequence.data.length > 0) {
                    oeisSequence = session.sequence.data;
                    uploadedSequenceName = session.sequence.uploadedName || '';
                }
                if (session.sequence.oeisNumber) {
                    document.getElementById('oeisNumber').value = session.sequence.oeisNumber;
                }
            }
            
            // Restore history
            historyData = session.history || [];
            
            // Recompute
            compute();
            
            alert(`Session "${session.name}" loaded successfully!`);
            switchTab('visualization');
        }
        
        function deleteSession(index) {
            const sessions = JSON.parse(localStorage.getItem('primePhaseSessions') || '[]');
            if (index < 0 || index >= sessions.length) return;
            
            if (confirm(`Delete session "${sessions[index].name}"?`)) {
                sessions.splice(index, 1);
                localStorage.setItem('primePhaseSessions', JSON.stringify(sessions));
                refreshSessions();
            }
        }
        
        function refreshSessions() {
            const sessions = JSON.parse(localStorage.getItem('primePhaseSessions') || '[]');
            const listEl = document.getElementById('sessionsList');
            
            if (!listEl) return;
            
            if (sessions.length === 0) {
                listEl.innerHTML = '<div style="padding: 24px; text-align: center; color: #888;">No saved sessions yet</div>';
                return;
            }
            
            let html = '';
            sessions.slice().reverse().forEach((session, i) => {
                const actualIndex = sessions.length - 1 - i;
                const date = new Date(session.timestamp).toLocaleString();
                html += `
                    <div style="background: #1a1a2a; border-radius: 6px; padding: 16px; border: 1px solid #2a2a4a;">
                        <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 8px;">
                            <div style="flex: 1;">
                                <div style="color: #ffd700; font-weight: 600; font-size: 1rem; margin-bottom: 4px;">${session.name}</div>
                                <div style="font-size: 0.75rem; color: #888;">${date}</div>
                            </div>
                            <div style="display: flex; gap: 8px;">
                                <button class="btn btn-secondary" onclick="loadSession(${actualIndex})" style="padding: 6px 12px; font-size: 0.75rem;">Load</button>
                                <button class="btn btn-secondary" onclick="deleteSession(${actualIndex})" style="padding: 6px 12px; font-size: 0.75rem; background: #4a1a1a;">Delete</button>
                            </div>
                        </div>
                        ${session.description ? `<div style="font-size: 0.85rem; color: #aaa; margin-bottom: 8px;">${session.description}</div>` : ''}
                        <div style="font-size: 0.75rem; color: #888; font-family: monospace; line-height: 1.6;">
                            M=${session.parameters.M} | t=${parseFloat(session.parameters.t).toFixed(2)} | X=${session.parameters.X} | 
                            α=${parseFloat(session.parameters.alpha).toFixed(2)} | β=${parseFloat(session.parameters.beta).toFixed(2)} | γ=${parseFloat(session.parameters.gamma).toFixed(2)}
                            ${session.history && session.history.length > 0 ? ` | History: ${session.history.length} pts` : ''}
                        </div>
                    </div>
                `;
            });
            
            listEl.innerHTML = html;
            updateSessionInfo();
        }
        
        function generateShareLink() {
            const params = new URLSearchParams();
            params.set('M', document.getElementById('modulus').value);
            params.set('t', document.getElementById('criticalT').value);
            params.set('X', document.getElementById('primeCutoff').value);
            params.set('alpha', document.getElementById('alpha').value);
            params.set('beta', document.getElementById('beta').value);
            params.set('gamma', document.getElementById('gamma').value);
            
            if (document.getElementById('useOEISToggle').checked) {
                params.set('useOEIS', '1');
                const oeisNum = document.getElementById('oeisNumber').value;
                if (oeisNum) params.set('seq', oeisNum);
            }
            
            const url = window.location.origin + window.location.pathname + '?' + params.toString();
            
            document.getElementById('shareLinkText').value = url;
            document.getElementById('shareLinkDisplay').style.display = 'block';
        }
        
        function copyShareLink() {
            const input = document.getElementById('shareLinkText');
            input.select();
            document.execCommand('copy');
            alert('Share link copied to clipboard!');
        }
        
        function loadFromURL() {
            const params = new URLSearchParams(window.location.search);
            
            if (params.has('M')) {
                document.getElementById('modulus').value = params.get('M');
                document.getElementById('mValue').textContent = params.get('M');
            }
            if (params.has('t')) {
                document.getElementById('criticalT').value = params.get('t');
                document.getElementById('tValue').textContent = parseFloat(params.get('t')).toFixed(4);
            }
            if (params.has('X')) {
                document.getElementById('primeCutoff').value = params.get('X');
                document.getElementById('xValue').textContent = params.get('X');
            }
            if (params.has('alpha')) {
                document.getElementById('alpha').value = params.get('alpha');
                document.getElementById('alphaValue').textContent = parseFloat(params.get('alpha')).toFixed(4);
            }
            if (params.has('beta')) {
                document.getElementById('beta').value = params.get('beta');
                document.getElementById('betaValue').textContent = parseFloat(params.get('beta')).toFixed(4);
            }
            if (params.has('gamma')) {
                document.getElementById('gamma').value = params.get('gamma');
                document.getElementById('gammaValue').textContent = parseFloat(params.get('gamma')).toFixed(4);
            }
            
            if (params.has('useOEIS') && params.get('useOEIS') === '1') {
                document.getElementById('useOEISToggle').checked = true;
                if (params.has('seq')) {
                    document.getElementById('oeisNumber').value = params.get('seq');
                    loadOEISSequence();
                }
            }
            
            if (params.size > 0) {
                compute();
            }
        }
        
        function updateSessionInfo() {
            const infoM = document.getElementById('infoM');
            const infoT = document.getElementById('infoT');
            const infoX = document.getElementById('infoX');
            const infoAlpha = document.getElementById('infoAlpha');
            const infoBeta = document.getElementById('infoBeta');
            const infoGamma = document.getElementById('infoGamma');
            const infoSequence = document.getElementById('infoSequence');
            const infoHistory = document.getElementById('infoHistory');
            
            if (!infoM || !infoT || !infoX || !infoAlpha || !infoBeta || !infoGamma || !infoSequence || !infoHistory) return;
            
            infoM.textContent = document.getElementById('modulus').value;
            infoT.textContent = parseFloat(document.getElementById('criticalT').value).toFixed(4);
            infoX.textContent = document.getElementById('primeCutoff').value;
            infoAlpha.textContent = parseFloat(document.getElementById('alpha').value).toFixed(4);
            infoBeta.textContent = parseFloat(document.getElementById('beta').value).toFixed(4);
            infoGamma.textContent = parseFloat(document.getElementById('gamma').value).toFixed(4);
            
            const seqText = document.getElementById('useOEISToggle').checked ? 
                (uploadedSequenceName || document.getElementById('oeisNumber').value || 'OEIS') : 
                'Standard Primes';
            infoSequence.textContent = seqText;
            infoHistory.textContent = historyData.length;
        }
        
        function exportAllSessions() {
            const sessions = JSON.parse(localStorage.getItem('primePhaseSessions') || '[]');
            const blob = new Blob([JSON.stringify(sessions, null, 2)], { type: 'application/json' });
            const link = document.createElement('a');
            link.download = `prime_phase_sessions_${Date.now()}.json`;
            link.href = URL.createObjectURL(blob);
            link.click();
        }
        
        function importSessions() {
            document.getElementById('sessionImportFile').click();
        }
        
        function handleSessionImport() {
            const file = document.getElementById('sessionImportFile').files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const imported = JSON.parse(e.target.result);
                    const existing = JSON.parse(localStorage.getItem('primePhaseSessions') || '[]');
                    const combined = existing.concat(imported);
                    localStorage.setItem('primePhaseSessions', JSON.stringify(combined));
                    alert(`Imported ${imported.length} session(s) successfully!`);
                    refreshSessions();
                } catch (error) {
                    alert('Error importing sessions: ' + error.message);
                }
            };
            reader.readAsText(file);
        }
        
        function uploadSequence() {
            const fileInput = document.getElementById('sequenceFile');
            const statusEl = document.getElementById('oeisStatus');
            const infoEl = document.getElementById('oeisInfo');
            const nameEl = document.getElementById('oeisName');
            const loadedEl = document.getElementById('oeisLoaded');
            
            if (!fileInput.files || fileInput.files.length === 0) {
                statusEl.textContent = 'Please select a file first.';
                statusEl.style.color = '#ff6464';
                return;
            }
            
            const file = fileInput.files[0];
            uploadedSequenceName = file.name.replace(/\.[^/.]+$/, ''); // Remove extension
            
            statusEl.textContent = `Processing ${file.name}...`;
            statusEl.style.color = '#ffd700';
            infoEl.style.display = 'none';
            
            const reader = new FileReader();
            
            reader.onload = function(e) {
                try {
                    const content = e.target.result;
                    let sequence = [];
                    
                    // Determine file type and parse accordingly
                    if (file.name.endsWith('.json')) {
                        // JSON format: expect array of numbers
                        const data = JSON.parse(content);
                        if (Array.isArray(data)) {
                            sequence = data.map(n => parseInt(n)).filter(n => !isNaN(n) && n > 0);
                        } else {
                            throw new Error('JSON must contain an array of numbers');
                        }
                    } else if (file.name.endsWith('.csv')) {
                        // CSV format: comma-separated values
                        sequence = content.split(/[,\n\r\s]+/)
                            .map(s => parseInt(s.trim()))
                            .filter(n => !isNaN(n) && n > 0);
                    } else {
                        // Text format: one number per line (also handles space-separated)
                        sequence = content.split(/[\n\r\s,]+/)
                            .map(s => parseInt(s.trim()))
                            .filter(n => !isNaN(n) && n > 0);
                    }
                    
                    if (sequence.length === 0) {
                        throw new Error('No valid positive integers found in file');
                    }
                    
                    // Limit to reasonable size
                    if (sequence.length > 10000) {
                        sequence = sequence.slice(0, 10000);
                        statusEl.textContent = `✓ Loaded (limited to first 10,000 terms)`;
                    } else {
                        statusEl.textContent = `✓ Successfully loaded ${sequence.length} terms`;
                    }
                    statusEl.style.color = '#64ff64';
                    
                    oeisSequence = sequence;
                    
                    infoEl.style.display = 'block';
                    nameEl.textContent = `Custom: ${uploadedSequenceName}`;
                    loadedEl.textContent = `Loaded: ${sequence.length} terms from upload`;
                    
                    const preview = sequence.slice(0, 10).join(', ');
                    loadedEl.textContent += `\nFirst terms: ${preview}${sequence.length > 10 ? '...' : ''}`;
                    
                    // Auto-enable OEIS toggle
                    document.getElementById('useOEISToggle').checked = true;
                    compute();
                    
                } catch (error) {
                    statusEl.textContent = `Error: ${error.message}`;
                    statusEl.style.color = '#ff6464';
                    infoEl.style.display = 'none';
                }
            };
            
            reader.onerror = function() {
                statusEl.textContent = 'Error reading file.';
                statusEl.style.color = '#ff6464';
            };
            
            reader.readAsText(file);
        }
        
        function loadOEISSequence() {
            const oeisNum = document.getElementById('oeisNumber').value.trim().toUpperCase();
            const termCount = parseInt(document.getElementById('oeisTermCount').value) || 1000;
            const statusEl = document.getElementById('oeisStatus');
            const infoEl = document.getElementById('oeisInfo');
            const nameEl = document.getElementById('oeisName');
            const loadedEl = document.getElementById('oeisLoaded');
            
            // Check if user selected upload option
            if (oeisNum === 'UPLOAD') {
                document.getElementById('uploadSection').style.display = 'block';
                statusEl.textContent = 'Choose a file to upload your custom sequence.';
                statusEl.style.color = '#ffd700';
                return;
            } else {
                document.getElementById('uploadSection').style.display = 'none';
            }
            
            if (!oeisNum.match(/^A\d{6}$/)) {
                statusEl.textContent = 'Invalid format. Use A000000 format (e.g., A000040 for primes).';
                statusEl.style.color = '#ff6464';
                infoEl.style.display = 'none';
                return;
            }
            
            // Check if sequence is hardcoded
            if (hardcodedSequences[oeisNum]) {
                const sequence = hardcodedSequences[oeisNum].slice(0, termCount);
                const names = {
                    'A000040': 'Prime numbers',
                    'A001359': 'Lesser of twin primes',
                    'A006512': 'Greater of twin primes',
                    'A000668': 'Mersenne primes',
                    'A019434': 'Fermat primes',
                    'A000045': 'Fibonacci numbers',
                    'A000032': 'Lucas numbers',
                    'A001519': 'Fibonacci numbers (odd indexed)',
                    'A000079': 'Powers of 2',
                    'A000244': 'Powers of 3',
                    'A000290': 'Perfect squares',
                    'A000578': 'Perfect cubes',
                    'A000217': 'Triangular numbers',
                    'A000326': 'Pentagonal numbers',
                    'A000384': 'Hexagonal numbers',
                    'A000142': 'Factorial numbers',
                    'A000108': 'Catalan numbers',
                    'A000984': 'Central binomial coefficients'
                };
                
                oeisSequence = sequence;
                statusEl.textContent = `✓ Successfully loaded ${sequence.length} terms (offline)`;
                statusEl.style.color = '#64ff64';
                
                infoEl.style.display = 'block';
                nameEl.textContent = names[oeisNum] || 'OEIS Sequence';
                loadedEl.textContent = `Loaded: ${sequence.length} terms (hardcoded data)`;
                
                const preview = sequence.slice(0, 10).join(', ');
                loadedEl.textContent += `\nFirst terms: ${preview}${sequence.length > 10 ? '...' : ''}`;
                
                if (document.getElementById('useOEISToggle').checked) {
                    compute();
                }
                return;
            }
            
            statusEl.textContent = `Loading ${termCount} terms from OEIS...`;
            statusEl.style.color = '#ffd700';
            infoEl.style.display = 'none';
            
            // First, try to get the b-file which contains many more terms
            const bFileUrl = `https://oeis.org/${oeisNum}/b${oeisNum.substring(1)}.txt`;
            
            fetch(bFileUrl)
                .then(response => {
                    if (response.ok) {
                        return response.text().then(text => ({source: 'bfile', data: text}));
                    }
                    // If b-file fails, fall back to JSON API
                    return fetch(`https://oeis.org/search?q=id:${oeisNum}&fmt=json`)
                        .then(r => r.json())
                        .then(json => ({source: 'json', data: json}));
                })
                .then(result => {
                    let sequence = [];
                    let sequenceName = '';
                    
                    if (result.source === 'bfile') {
                        // Parse b-file format: "n a(n)" on each line
                        const lines = result.data.split('\n');
                        for (let line of lines) {
                            line = line.trim();
                            if (line && !line.startsWith('#')) {
                                const parts = line.split(/\s+/);
                                if (parts.length >= 2) {
                                    const value = parseInt(parts[1]);
                                    if (!isNaN(value) && value > 0) {
                                        sequence.push(value);
                                        if (sequence.length >= termCount) break;
                                    }
                                }
                            }
                        }
                        
                        // Get sequence name from JSON API
                        fetch(`https://oeis.org/search?q=id:${oeisNum}&fmt=json`)
                            .then(r => r.json())
                            .then(json => {
                                if (json.results && json.results.length > 0) {
                                    sequenceName = json.results[0].name;
                                }
                                displaySequenceInfo(sequence, sequenceName, 'b-file');
                            })
                            .catch(() => {
                                displaySequenceInfo(sequence, 'Extended b-file sequence', 'b-file');
                            });
                    } else if (result.source === 'json') {
                        // Parse JSON API response
                        if (result.data.results && result.data.results.length > 0) {
                            const seqData = result.data.results[0];
                            sequenceName = seqData.name;
                            
                            // Parse the data field
                            const dataStr = seqData.data;
                            sequence = dataStr.split(',')
                                .map(s => parseInt(s.trim()))
                                .filter(n => !isNaN(n) && n > 0)
                                .slice(0, termCount);
                            
                            displaySequenceInfo(sequence, sequenceName, 'JSON API');
                        } else {
                            throw new Error('Sequence not found');
                        }
                    }
                    
                    function displaySequenceInfo(seq, name, source) {
                        if (seq.length > 0) {
                            oeisSequence = seq;
                            statusEl.textContent = `✓ Successfully loaded ${seq.length} terms`;
                            statusEl.style.color = '#64ff64';
                            
                            infoEl.style.display = 'block';
                            nameEl.textContent = name || 'OEIS Sequence';
                            loadedEl.textContent = `Loaded: ${seq.length} terms (from ${source})`;
                            
                            // Show first few terms as preview
                            const preview = seq.slice(0, 10).join(', ');
                            loadedEl.textContent += `\nFirst terms: ${preview}${seq.length > 10 ? '...' : ''}`;
                            
                            if (document.getElementById('useOEISToggle').checked) {
                                compute();
                            }
                        } else {
                            statusEl.textContent = 'No valid numeric data found in sequence.';
                            statusEl.style.color = '#ff6464';
                            infoEl.style.display = 'none';
                        }
                    }
                })
                .catch(error => {
                    statusEl.textContent = 'Error: Sequence not available. Please use offline sequences marked (OFFLINE).';
                    statusEl.style.color = '#ff6464';
                    infoEl.style.display = 'none';
                    console.error('OEIS fetch error:', error);
                });
        }
        
        function compute() {
            const M = parseInt(document.getElementById('modulus').value);
            const t = parseFloat(document.getElementById('criticalT').value);
            const X = parseInt(document.getElementById('primeCutoff').value);
            const alpha = parseFloat(document.getElementById('alpha').value);
            const beta = parseFloat(document.getElementById('beta').value);
            const gamma = parseFloat(document.getElementById('gamma').value);
            
            useOEIS = document.getElementById('useOEISToggle').checked;
            
            if (useOEIS && oeisSequence.length > 0) {
                primes = oeisSequence.filter(n => n <= X);
            } else {
                primes = sievePrimes(X);
            }
            pathData = [];
            
            let re = 0, im = 0, pathLength = 0, maxExcursion = 0;
            let prevAngle = 0, totalAngle = 0;
            let sumAbsTerms = 0;
            
            primes.forEach((p, idx) => {
                const modPhase = 2 * Math.PI * gamma * p / M;
                const critPhase = -alpha * t * Math.log(p);
                const totalPhase = modPhase + critPhase;
                const mag = 1 / Math.pow(p, beta);
                
                const dRe = mag * Math.cos(totalPhase);
                const dIm = mag * Math.sin(totalPhase);
                
                re += dRe;
                im += dIm;
                pathLength += mag;
                sumAbsTerms += mag;
                
                const dist = Math.sqrt(re * re + im * im);
                maxExcursion = Math.max(maxExcursion, dist);
                
                const angle = Math.atan2(im, re);
                if (idx > 0) {
                    let dAngle = angle - prevAngle;
                    if (dAngle > Math.PI) dAngle -= 2 * Math.PI;
                    if (dAngle < -Math.PI) dAngle += 2 * Math.PI;
                    totalAngle += dAngle;
                }
                prevAngle = angle;
                
                pathData.push({ re, im, p });
            });
            
            const magnitude = Math.sqrt(re * re + im * im);
            const coherence = pathLength > 0 ? 1 - (magnitude / pathLength) : 0;
            const efficiency = pathLength > 0 ? magnitude / pathLength : 0;
            const windingNumber = totalAngle / (2 * Math.PI);
            const cancellationIndex = sumAbsTerms > 0 ? 1 - (magnitude / sumAbsTerms) : 0;
            
            document.getElementById('statMagnitude').textContent = magnitude.toFixed(6);
            document.getElementById('statCoherence').textContent = coherence.toFixed(6);
            document.getElementById('statReal').textContent = re.toFixed(6);
            document.getElementById('statImag').textContent = im.toFixed(6);
            document.getElementById('statPrimeCount').textContent = primes.length;
            document.getElementById('statPathLength').textContent = pathLength.toFixed(4);
            document.getElementById('statEfficiency').textContent = efficiency.toFixed(6);
            document.getElementById('statMaxExcursion').textContent = maxExcursion.toFixed(4);
            document.getElementById('statWinding').textContent = windingNumber.toFixed(4);
            document.getElementById('statCancellation').textContent = cancellationIndex.toFixed(6);
            
            if (document.getElementById('enableHistory').checked) {
                historyData.push({ t, magnitude, coherence });
                if (historyData.length > 500) historyData.shift();
                document.getElementById('historyStats').textContent = `Data Points: ${historyData.length}`;
            }
            
            render();
            renderPhaseSpace();
            renderHistory();
        }
        
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : { r: 255, g: 255, b: 255 };
        }
        
        function getLegendPosition(canvas, width, height) {
            const margin = 15;
            const positions = [
                { x: margin, y: margin, align: 'left' },
                { x: canvas.width - width - margin, y: margin, align: 'right' },
                { x: margin, y: canvas.height - height - margin, align: 'left' },
                { x: canvas.width - width - margin, y: canvas.height - height - margin, align: 'right' }
            ];
            return positions[0];
        }
        
        function drawAdaptiveLegend(ctx, canvas, title, items) {
            if (!document.getElementById('showLegend').checked) return;
            
            ctx.save();
            ctx.font = '11px monospace';
            
            const lineHeight = 16;
            const padding = 10;
            const titleHeight = 18;
            
            let maxWidth = ctx.measureText(title).width;
            items.forEach(item => {
                const textWidth = ctx.measureText(item.label + ': ' + item.value).width;
                maxWidth = Math.max(maxWidth, textWidth);
            });
            
            const boxWidth = maxWidth + padding * 2;
            const boxHeight = titleHeight + items.length * lineHeight + padding;
            
            const pos = getLegendPosition(canvas, boxWidth, boxHeight);
            
            ctx.fillStyle = 'rgba(0, 0, 0, 0.85)';
            ctx.fillRect(pos.x, pos.y, boxWidth, boxHeight);
            ctx.strokeStyle = '#3a3a5a';
            ctx.lineWidth = 1;
            ctx.strokeRect(pos.x, pos.y, boxWidth, boxHeight);
            
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 11px monospace';
            ctx.fillText(title, pos.x + padding, pos.y + padding + 11);
            
            ctx.strokeStyle = '#3a3a5a';
            ctx.beginPath();
            ctx.moveTo(pos.x + padding, pos.y + titleHeight - 2);
            ctx.lineTo(pos.x + boxWidth - padding, pos.y + titleHeight - 2);
            ctx.stroke();
            
            ctx.font = '10px monospace';
            items.forEach((item, i) => {
                const y = pos.y + titleHeight + (i + 1) * lineHeight;
                ctx.fillStyle = '#aaa';
                ctx.fillText(item.label + ':', pos.x + padding, y);
                ctx.fillStyle = '#ffd700';
                const labelWidth = ctx.measureText(item.label + ': ').width;
                ctx.fillText(item.value, pos.x + padding + labelWidth, y);
            });
            
            ctx.restore();
        }
        
        function render() {
            const canvas = document.getElementById('mainCanvas');
            const ctx = canvas.getContext('2d');
            const w = canvas.width, h = canvas.height;
            const cx = w / 2, cy = h / 2;
            const state = canvasStates.main;
            const vizMode = document.getElementById('vizMode').value;
            
            // Apply slider zoom
            const sliderZoom = parseInt(document.getElementById('canvasZoomSlider').value) / 100;
            
            ctx.save();
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, w, h);
            
            ctx.translate(cx, cy);
            ctx.scale(sliderZoom, sliderZoom);
            ctx.translate(-cx, -cy);
            ctx.translate(state.offsetX, state.offsetY);
            
            if (pathData.length === 0) {
                ctx.restore();
                return;
            }
            
            const maxDist = Math.max(...pathData.map(p => Math.max(Math.abs(p.re), Math.abs(p.im))), 1);
            const scale = Math.min(w, h) * 0.35 / maxDist;
            
            // Draw grid
            const gridColor = hexToRgb(document.getElementById('gridColor').value);
            const gridOpacity = parseInt(document.getElementById('gridOpacity').value) / 100;
            
            if (document.getElementById('showGrid').checked) {
                ctx.strokeStyle = `rgba(${gridColor.r}, ${gridColor.g}, ${gridColor.b}, ${gridOpacity * 0.5})`;
                ctx.lineWidth = 1 / sliderZoom;
                for (let i = -10; i <= 10; i++) {
                    const x = cx + i * scale * maxDist / 5;
                    ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, h); ctx.stroke();
                    const y = cy + i * scale * maxDist / 5;
                    ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(w, y); ctx.stroke();
                }
                ctx.strokeStyle = `rgba(${gridColor.r}, ${gridColor.g}, ${gridColor.b}, ${gridOpacity})`;
                ctx.lineWidth = 1.5 / sliderZoom;
                ctx.beginPath(); ctx.moveTo(0, cy); ctx.lineTo(w, cy); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(cx, 0); ctx.lineTo(cx, h); ctx.stroke();
            }
            
            const colorScheme = document.getElementById('colorScheme').value;
            const useGradient = document.getElementById('useGradient').checked;
            
            if (vizMode === 'heatmap') {
                renderHeatMap(ctx, cx, cy, scale, colorScheme);
            } else if (vizMode === 'spiral') {
                renderSpiral(ctx, cx, cy, scale, colorScheme);
            } else if (vizMode === 'contour') {
                renderContours(ctx, cx, cy, scale, colorScheme);
            } else {
                // Default vector path
                if (document.getElementById('showPath').checked) {
                    const opacity = parseInt(document.getElementById('pathOpacity').value) / 100;
                    
                    ctx.lineWidth = 2 / sliderZoom;
                    for (let i = 1; i < pathData.length; i++) {
                        const t = i / (pathData.length - 1);
                        let color;
                        
                        if (colorScheme === 'default') {
                            const pathStartColor = hexToRgb(document.getElementById('pathColor').value);
                            const pathEndColor = hexToRgb(document.getElementById('pathEndColor').value);
                            const r = Math.round(pathStartColor.r + (pathEndColor.r - pathStartColor.r) * t);
                            const g = Math.round(pathStartColor.g + (pathEndColor.g - pathStartColor.g) * t);
                            const b = Math.round(pathStartColor.b + (pathEndColor.b - pathStartColor.b) * t);
                            color = {r, g, b};
                        } else {
                            color = getColorFromScheme(colorScheme, t);
                        }
                        
                        ctx.strokeStyle = `rgba(${color.r}, ${color.g}, ${color.b}, ${opacity})`;
                        ctx.beginPath();
                        ctx.moveTo(cx + pathData[i-1].re * scale, cy - pathData[i-1].im * scale);
                        ctx.lineTo(cx + pathData[i].re * scale, cy - pathData[i].im * scale);
                        ctx.stroke();
                    }
                }
            }
            
            // Draw origin and result vector
            const originColor = hexToRgb(document.getElementById('originColor').value);
            ctx.beginPath();
            ctx.arc(cx, cy, 6 / sliderZoom, 0, 2 * Math.PI);
            ctx.fillStyle = `rgb(${originColor.r}, ${originColor.g}, ${originColor.b})`;
            ctx.fill();
            
            const last = pathData[pathData.length - 1];
            const endX = cx + last.re * scale;
            const endY = cy - last.im * scale;
            
            const resultColor = hexToRgb(document.getElementById('resultColor').value);
            ctx.strokeStyle = `rgb(${resultColor.r}, ${resultColor.g}, ${resultColor.b})`;
            ctx.lineWidth = 3 / sliderZoom;
            ctx.beginPath();
            ctx.moveTo(cx, cy);
            ctx.lineTo(endX, endY);
            ctx.stroke();
            
            const arrowSize = 12 / sliderZoom;
            const angle = Math.atan2(cy - endY, endX - cx);
            ctx.beginPath();
            ctx.moveTo(endX, endY);
            ctx.lineTo(endX - arrowSize * Math.cos(angle - 0.3), endY + arrowSize * Math.sin(angle - 0.3));
            ctx.lineTo(endX - arrowSize * Math.cos(angle + 0.3), endY + arrowSize * Math.sin(angle + 0.3));
            ctx.closePath();
            ctx.fillStyle = `rgb(${resultColor.r}, ${resultColor.g}, ${resultColor.b})`;
            ctx.fill();
            
            ctx.beginPath();
            ctx.arc(endX, endY, 8 / sliderZoom, 0, 2 * Math.PI);
            ctx.fillStyle = `rgb(${resultColor.r}, ${resultColor.g}, ${resultColor.b})`;
            ctx.fill();
            
            ctx.restore();
            
            const M = document.getElementById('modulus').value;
            const t = parseFloat(document.getElementById('criticalT').value).toFixed(4);
            const X = document.getElementById('primeCutoff').value;
            const primeCount = primes.length;
            
            let sequenceType = 'Standard Primes';
            if (useOEIS && oeisSequence.length > 0) {
                if (uploadedSequenceName) {
                    sequenceType = uploadedSequenceName;
                } else {
                    const oeisNum = document.getElementById('oeisNumber').value;
                    const sequenceNames = {
                        'A000040': 'Primes', 'A001359': 'Twin Primes (Lesser)',
                        'A006512': 'Twin Primes (Greater)', 'A000668': 'Mersenne Primes',
                        'A019434': 'Fermat Primes', 'A000045': 'Fibonacci',
                        'A000032': 'Lucas', 'A001519': 'Fibonacci (Odd)',
                        'A000079': 'Powers of 2', 'A000244': 'Powers of 3',
                        'A000290': 'Squares', 'A000578': 'Cubes',
                        'A000217': 'Triangular', 'A000326': 'Pentagonal',
                        'A000384': 'Hexagonal', 'A000142': 'Factorials',
                        'A000108': 'Catalan', 'A000984': 'Binomial'
                    };
                    sequenceType = sequenceNames[oeisNum] || 'OEIS Sequence';
                }
            }
            
            drawAdaptiveLegend(ctx, canvas, 'Vector Space Parameters', [
                { label: 'Sequence', value: sequenceType },
                { label: 'Modulus M', value: M },
                { label: 'Height t', value: t },
                { label: 'Terms', value: primeCount },
                { label: 'Magnitude', value: document.getElementById('statMagnitude').textContent }
            ]);
        }
        
        function renderHeatMap(ctx, cx, cy, scale, colorScheme) {
            const canvas = ctx.canvas;
            const gridSize = 100;
            const cellSize = Math.min(canvas.width, canvas.height) / gridSize;
            const density = new Array(gridSize).fill(0).map(() => new Array(gridSize).fill(0));
            
            // Calculate density
            pathData.forEach(p => {
                const x = Math.floor((p.re * scale + cx) / cellSize);
                const y = Math.floor((cy - p.im * scale) / cellSize);
                if (x >= 0 && x < gridSize && y >= 0 && y < gridSize) {
                    density[y][x]++;
                }
            });
            
            let maxDensity = 1;
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    if (density[y][x] > maxDensity) {
                        maxDensity = density[y][x];
                    }
                }
            }
            
            // Draw heat map
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    if (density[y][x] > 0) {
                        const t = density[y][x] / maxDensity;
                        let color;
                        if (colorScheme === 'default') {
                            color = {
                                r: Math.round(255 * t), 
                                g: Math.round(100 * (1-t)), 
                                b: Math.round(100 * (1-t))
                            };
                        } else {
                            color = getColorFromScheme(colorScheme, t);
                        }
                        
                        ctx.fillStyle = `rgba(${color.r}, ${color.g}, ${color.b}, 0.7)`;
                        ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
                    }
                }
            }
        }
        
        function renderSpiral(ctx, cx, cy, scale, colorScheme) {
            ctx.lineWidth = 2;
            for (let i = 1; i < pathData.length; i++) {
                const t = i / (pathData.length - 1);
                const color = colorScheme === 'default' ?
                    {r: 100, g: 200, b: 255} :
                    getColorFromScheme(colorScheme, t);
                
                const r1 = Math.sqrt(pathData[i-1].re * pathData[i-1].re + pathData[i-1].im * pathData[i-1].im);
                const theta1 = Math.atan2(pathData[i-1].im, pathData[i-1].re);
                const r2 = Math.sqrt(pathData[i].re * pathData[i].re + pathData[i].im * pathData[i].im);
                const theta2 = Math.atan2(pathData[i].im, pathData[i].re);
                
                ctx.strokeStyle = `rgb(${color.r}, ${color.g}, ${color.b})`;
                ctx.beginPath();
                ctx.arc(cx, cy, r1 * scale, theta1, theta2);
                ctx.stroke();
            }
        }
        
        function renderContours(ctx, cx, cy, scale, colorScheme) {
            const distances = pathData.map(p => Math.sqrt(p.re * p.re + p.im * p.im));
            const maxDist = Math.max(...distances);
            
            for (let level = 0.1; level <= 1; level += 0.1) {
                const r = level * maxDist * scale;
                const color = colorScheme === 'default' ?
                    {r: Math.round(255 * level), g: Math.round(200 * (1-level)), b: 100} :
                    getColorFromScheme(colorScheme, level);
                
                ctx.strokeStyle = `rgba(${color.r}, ${color.g}, ${color.b}, 0.6)`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(cx, cy, r, 0, 2 * Math.PI);
                ctx.stroke();
            }
        }
        
        function renderPhaseSpace() {
            const canvas = document.getElementById('phaseCanvas');
            const ctx = canvas.getContext('2d');
            const w = canvas.width, h = canvas.height;
            const cx = w / 2, cy = h / 2;
            const state = canvasStates.phase;
            
            ctx.save();
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, w, h);
            
            ctx.translate(state.offsetX, state.offsetY);
            ctx.scale(state.zoom, state.zoom);
            
            if (pathData.length === 0) {
                ctx.restore();
                return;
            }
            
            const maxDist = Math.max(...pathData.map(p => Math.sqrt(p.re * p.re + p.im * p.im)), 1);
            const scale = Math.min(w, h) * 0.35 / maxDist;
            
            const gridColor = hexToRgb(document.getElementById('gridColor').value);
            const gridOpacity = parseInt(document.getElementById('gridOpacity').value) / 100;
            
            ctx.strokeStyle = `rgba(${gridColor.r}, ${gridColor.g}, ${gridColor.b}, ${gridOpacity * 0.5})`;
            ctx.lineWidth = 1 / state.zoom;
            [0.25, 0.5, 0.75, 1].forEach(r => {
                ctx.beginPath();
                ctx.arc(cx, cy, r * maxDist * scale, 0, 2 * Math.PI);
                ctx.stroke();
            });
            
            const pathColor = hexToRgb(document.getElementById('pathColor').value);
            const useGradient = document.getElementById('useGradient').checked;
            
            if (useGradient) {
                const pathStartColor = hexToRgb(document.getElementById('pathColor').value);
                const pathEndColor = hexToRgb(document.getElementById('pathEndColor').value);
                
                ctx.lineWidth = 1.5 / state.zoom;
                for (let i = 1; i < pathData.length; i++) {
                    const t = i / (pathData.length - 1);
                    const r = Math.round(pathStartColor.r + (pathEndColor.r - pathStartColor.r) * t);
                    const g = Math.round(pathStartColor.g + (pathEndColor.g - pathStartColor.g) * t);
                    const b = Math.round(pathStartColor.b + (pathEndColor.b - pathStartColor.b) * t);
                    
                    ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, 0.7)`;
                    ctx.beginPath();
                    ctx.moveTo(cx + pathData[i-1].re * scale, cy - pathData[i-1].im * scale);
                    ctx.lineTo(cx + pathData[i].re * scale, cy - pathData[i].im * scale);
                    ctx.stroke();
                }
            } else {
                const gradient = ctx.createLinearGradient(0, 0, w, h);
                gradient.addColorStop(0, `rgba(${pathColor.r}, ${pathColor.g}, ${pathColor.b}, 0.7)`);
                gradient.addColorStop(1, `rgba(${Math.min(pathColor.r + 50, 255)}, ${Math.min(pathColor.g + 50, 255)}, ${Math.min(pathColor.b + 50, 255)}, 0.7)`);
                ctx.strokeStyle = gradient;
                ctx.lineWidth = 1.5 / state.zoom;
                ctx.beginPath();
                ctx.moveTo(cx, cy);
                pathData.forEach(p => {
                    ctx.lineTo(cx + p.re * scale, cy - p.im * scale);
                });
                ctx.stroke();
            }
            
            const originColor = hexToRgb(document.getElementById('originColor').value);
            ctx.beginPath();
            ctx.arc(cx, cy, 5 / state.zoom, 0, 2 * Math.PI);
            ctx.fillStyle = `rgb(${originColor.r}, ${originColor.g}, ${originColor.b})`;
            ctx.fill();
            
            const last = pathData[pathData.length - 1];
            const resultColor = hexToRgb(document.getElementById('resultColor').value);
            ctx.beginPath();
            ctx.arc(cx + last.re * scale, cy - last.im * scale, 6 / state.zoom, 0, 2 * Math.PI);
            ctx.fillStyle = `rgb(${resultColor.r}, ${resultColor.g}, ${resultColor.b})`;
            ctx.fill();
            
            ctx.restore();
            
            const maxExc = document.getElementById('statMaxExcursion').textContent;
            const winding = document.getElementById('statWinding').textContent;
            
            drawAdaptiveLegend(ctx, canvas, 'Phase Space Metrics', [
                { label: 'Max Radius', value: maxExc },
                { label: 'Winding #', value: winding },
                { label: 'Efficiency', value: document.getElementById('statEfficiency').textContent }
            ]);
        }
        
        function renderHistory() {
            const canvas = document.getElementById('historyCanvas');
            const ctx = canvas.getContext('2d');
            const w = canvas.width, h = canvas.height;
            const state = canvasStates.history;
            
            ctx.save();
            ctx.fillStyle = '#0a0a10';
            ctx.fillRect(0, 0, w, h);
            
            ctx.translate(state.offsetX, state.offsetY);
            ctx.scale(state.zoom, state.zoom);
            
            if (historyData.length < 2) {
                ctx.restore();
                return;
            }
            
            const maxMag = Math.max(...historyData.map(d => d.magnitude), 1);
            const xScale = (w - 40) / (historyData.length - 1);
            const yScale = (h - 40) / maxMag;
            
            const resultColor = hexToRgb(document.getElementById('resultColor').value);
            ctx.strokeStyle = `rgb(${resultColor.r}, ${resultColor.g}, ${resultColor.b})`;
            ctx.lineWidth = 2 / state.zoom;
            ctx.beginPath();
            historyData.forEach((d, i) => {
                const x = 20 + i * xScale;
                const y = h - 20 - d.magnitude * yScale;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            });
            ctx.stroke();
            
            ctx.fillStyle = `rgb(${resultColor.r}, ${resultColor.g}, ${resultColor.b})`;
            historyData.forEach((d, i) => {
                const x = 20 + i * xScale;
                const y = h - 20 - d.magnitude * yScale;
                ctx.beginPath();
                ctx.arc(x, y, 2 / state.zoom, 0, 2 * Math.PI);
                ctx.fill();
            });
            
            ctx.restore();
            
            const points = historyData.length;
            const avgMag = (historyData.reduce((sum, d) => sum + d.magnitude, 0) / points).toFixed(6);
            
            drawAdaptiveLegend(ctx, canvas, 'History Statistics', [
                { label: 'Points', value: points.toString() },
                { label: 'Avg Mag', value: avgMag },
                { label: 'Max Mag', value: maxMag.toFixed(6) }
            ]);
        }
        
        function setupCanvasInteraction(canvasId, stateKey) {
            const canvas = document.getElementById(canvasId);
            const state = canvasStates[stateKey];
            
            // Use slider zoom for main and phase canvases
            if (canvasId === 'mainCanvas' || canvasId === 'phaseCanvas') {
                return; // Zoom controlled by slider
            }
            
            canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                const delta = e.deltaY > 0 ? 0.9 : 1.1;
                state.zoom = Math.max(0.1, Math.min(10, state.zoom * delta));
                
                if (stateKey === 'main') render();
                else if (stateKey === 'phase') renderPhaseSpace();
                else if (stateKey === 'history') renderHistory();
            });
            
            canvas.addEventListener('mousedown', (e) => {
                state.isDragging = true;
                state.lastX = e.offsetX;
                state.lastY = e.offsetY;
            });
            
            canvas.addEventListener('mousemove', (e) => {
                if (!state.isDragging) return;
                const dx = e.offsetX - state.lastX;
                const dy = e.offsetY - state.lastY;
                state.offsetX += dx;
                state.offsetY += dy;
                state.lastX = e.offsetX;
                state.lastY = e.offsetY;
                
                if (stateKey === 'main') render();
                else if (stateKey === 'phase') renderPhaseSpace();
                else if (stateKey === 'history') renderHistory();
            });
            
            canvas.addEventListener('mouseup', () => {
                state.isDragging = false;
            });
            
            canvas.addEventListener('mouseleave', () => {
                state.isDragging = false;
            });
            
            // Touch support for mobile
            canvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const touch = e.touches[0];
                state.isDragging = true;
                state.lastX = touch.clientX;
                state.lastY = touch.clientY;
            });
            
            canvas.addEventListener('touchmove', (e) => {
                e.preventDefault();
                if (!state.isDragging) return;
                const touch = e.touches[0];
                const dx = touch.clientX - state.lastX;
                const dy = touch.clientY - state.lastY;
                state.offsetX += dx;
                state.offsetY += dy;
                state.lastX = touch.clientX;
                state.lastY = touch.clientY;
                
                if (stateKey === 'main') render();
                else if (stateKey === 'phase') renderPhaseSpace();
                else if (stateKey === 'history') renderHistory();
            });
            
            canvas.addEventListener('touchend', () => {
                state.isDragging = false;
            });
        }
        
        function resetView(canvasKey) {
            const state = canvasStates[canvasKey];
            state.zoom = 1;
            state.offsetX = 0;
            state.offsetY = 0;
            
            if (canvasKey === 'main') {
                document.getElementById('canvasZoomSlider').value = 100;
                document.getElementById('canvasZoomValue').textContent = '100%';
                render();
            } else if (canvasKey === 'phase') {
                renderPhaseSpace();
            } else if (canvasKey === 'history') {
                renderHistory();
            }
        }
        
        function exportCanvas(canvasKey) {
            const canvasMap = {
                'main': 'mainCanvas',
                'phase': 'phaseCanvas',
                'history': 'historyCanvas'
            };
            
            const sourceCanvas = document.getElementById(canvasMap[canvasKey]);
            const exportCanvas = document.createElement('canvas');
            exportCanvas.width = 3840;
            exportCanvas.height = canvasKey === 'main' ? 2160 : (canvasKey === 'phase' ? 1080 : 800);
            
            const ctx = exportCanvas.getContext('2d');
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, exportCanvas.width, exportCanvas.height);
            
            const scaleX = exportCanvas.width / sourceCanvas.width;
            const scaleY = exportCanvas.height / sourceCanvas.height;
            ctx.scale(scaleX, scaleY);
            ctx.drawImage(sourceCanvas, 0, 0);
            
            const M = document.getElementById('modulus').value;
            const t = parseFloat(document.getElementById('criticalT').value).toFixed(4);
            const X = document.getElementById('primeCutoff').value;
            
            const titles = {
                'main': `Vector_Space_M${M}_t${t}_X${X}`,
                'phase': `Phase_Space_M${M}_t${t}_X${X}`,
                'history': `Magnitude_History_${historyData.length}pts`
            };
            
            const link = document.createElement('a');
            link.download = `${titles[canvasKey]}_4K.png`;
            link.href = exportCanvas.toDataURL('image/png');
            link.click();
        }
        
        function exportAllPNG() {
            ['main', 'phase', 'history'].forEach(key => exportCanvas(key));
        }
        
        function exportAllSVG() {
            ['main', 'phase'].forEach(canvasKey => {
                const M = document.getElementById('modulus').value;
                const t = parseFloat(document.getElementById('criticalT').value).toFixed(4);
                const X = document.getElementById('primeCutoff').value;
                
                const dims = canvasKey === 'main' ? { w: 1200, h: 800 } : { w: 1200, h: 300 };
                let svg = `<svg xmlns="http://www.w3.org/2000/svg" width="${dims.w}" height="${dims.h}" style="background:#000">`;
                
                const gridColor = hexToRgb(document.getElementById('gridColor').value);
                const gridOpacity = parseInt(document.getElementById('gridOpacity').value) / 100;
                
                if (document.getElementById('showGrid').checked && canvasKey === 'main') {
                    svg += `<line x1="0" y1="${dims.h/2}" x2="${dims.w}" y2="${dims.h/2}" stroke="rgba(${gridColor.r},${gridColor.g},${gridColor.b},${gridOpacity})" stroke-width="1.5"/>`;
                    svg += `<line x1="${dims.w/2}" y1="0" x2="${dims.w/2}" y2="${dims.h}" stroke="rgba(${gridColor.r},${gridColor.g},${gridColor.b},${gridOpacity})" stroke-width="1.5"/>`;
                }
                
                if (pathData.length > 0) {
                    const maxDist = canvasKey === 'main' ? 
                        Math.max(...pathData.map(p => Math.max(Math.abs(p.re), Math.abs(p.im))), 1) :
                        Math.max(...pathData.map(p => Math.sqrt(p.re * p.re + p.im * p.im)), 1);
                    const scale = Math.min(dims.w, dims.h) * 0.35 / maxDist;
                    const cx = dims.w / 2, cy = dims.h / 2;
                    
                    const pathColor = hexToRgb(document.getElementById('pathColor').value);
                    const opacity = parseInt(document.getElementById('pathOpacity').value) / 100;
                    const useGradient = document.getElementById('useGradient').checked;
                    
                    if (useGradient) {
                        const pathEndColor = hexToRgb(document.getElementById('pathEndColor').value);
                        for (let i = 1; i < pathData.length; i++) {
                            const t = i / (pathData.length - 1);
                            const r = Math.round(pathColor.r + (pathEndColor.r - pathColor.r) * t);
                            const g = Math.round(pathColor.g + (pathEndColor.g - pathColor.g) * t);
                            const b = Math.round(pathColor.b + (pathEndColor.b - pathColor.b) * t);
                            
                            const x1 = cx + pathData[i-1].re * scale;
                            const y1 = cy - pathData[i-1].im * scale;
                            const x2 = cx + pathData[i].re * scale;
                            const y2 = cy - pathData[i].im * scale;
                            
                            svg += `<line x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}" stroke="rgba(${r},${g},${b},${opacity})" stroke-width="2"/>`;
                        }
                    } else {
                        let pathStr = `M${cx},${cy} `;
                        pathData.forEach(p => {
                            pathStr += `L${cx + p.re * scale},${cy - p.im * scale} `;
                        });
                        svg += `<path d="${pathStr}" fill="none" stroke="rgba(${pathColor.r},${pathColor.g},${pathColor.b},${opacity})" stroke-width="2"/>`;
                    }
                    
                    const last = pathData[pathData.length - 1];
                    const resultColor = hexToRgb(document.getElementById('resultColor').value);
                    svg += `<line x1="${cx}" y1="${cy}" x2="${cx + last.re * scale}" y2="${cy - last.im * scale}" stroke="rgb(${resultColor.r},${resultColor.g},${resultColor.b})" stroke-width="3"/>`;
                    svg += `<circle cx="${cx + last.re * scale}" cy="${cy - last.im * scale}" r="8" fill="rgb(${resultColor.r},${resultColor.g},${resultColor.b})"/>`;
                    
                    const originColor = hexToRgb(document.getElementById('originColor').value);
                    svg += `<circle cx="${cx}" cy="${cy}" r="6" fill="rgb(${originColor.r},${originColor.g},${originColor.b})"/>`;
                }
                
                svg += `</svg>`;
                
                const blob = new Blob([svg], { type: 'image/svg+xml' });
                const link = document.createElement('a');
                const titles = {
                    'main': `Vector_Space_M${M}_t${t}_X${X}`,
                    'phase': `Phase_Space_M${M}_t${t}_X${X}`
                };
                link.download = `${titles[canvasKey]}.svg`;
                link.href = URL.createObjectURL(blob);
                link.click();
            });
        }
        
        function exportCSV() {
            const M = document.getElementById('modulus').value;
            const t = parseFloat(document.getElementById('criticalT').value).toFixed(6);
            const X = document.getElementById('primeCutoff').value;
            const alpha = document.getElementById('alpha').value;
            const beta = document.getElementById('beta').value;
            const gamma = document.getElementById('gamma').value;
            
            let csv = `Prime-Phase Vector Data Export\n`;
            csv += `Modulus M,${M}\nHeight t,${t}\nCutoff X,${X}\n`;
            csv += `Alpha,${alpha}\nBeta,${beta}\nGamma,${gamma}\n\n`;
            csv += `Magnitude,${document.getElementById('statMagnitude').textContent}\n`;
            csv += `Coherence,${document.getElementById('statCoherence').textContent}\n`;
            csv += `Efficiency,${document.getElementById('statEfficiency').textContent}\n`;
            csv += `Winding Number,${document.getElementById('statWinding').textContent}\n\n`;
            csv += `Index,Prime,Real,Imaginary,Distance,Phase\n`;
            
            pathData.forEach((p, i) => {
                const dist = Math.sqrt(p.re * p.re + p.im * p.im);
                const phase = Math.atan2(p.im, p.re);
                csv += `${i+1},${p.p},${p.re.toFixed(8)},${p.im.toFixed(8)},${dist.toFixed(8)},${phase.toFixed(8)}\n`;
            });
            
            const blob = new Blob([csv], { type: 'text/csv' });
            const link = document.createElement('a');
            link.download = `Vector_Data_M${M}_t${t}_X${X}_P${pathData.length}.csv`;
            link.href = URL.createObjectURL(blob);
            link.click();
        }
        
        function exportHistory() {
            let csv = `Magnitude History Export\n`;
            csv += `Total Points,${historyData.length}\n\n`;
            csv += `t_Parameter,Magnitude,Coherence,Efficiency\n`;
            historyData.forEach(d => {
                const efficiency = 1 - d.coherence;
                csv += `${d.t.toFixed(6)},${d.magnitude.toFixed(8)},${d.coherence.toFixed(8)},${efficiency.toFixed(8)}\n`;
            });
            
            const blob = new Blob([csv], { type: 'text/csv' });
            const link = document.createElement('a');
            link.download = `Magnitude_History_${historyData.length}points.csv`;
            link.href = URL.createObjectURL(blob);
            link.click();
        }
        
        function toggleAnimation() {
            isAnimating = !isAnimating;
            document.getElementById('animateBtn').textContent = isAnimating ? 'Stop Animation' : 'Animate t Parameter';
            if (isAnimating) animate();
            else if (animationId) cancelAnimationFrame(animationId);
        }
        
        function animate() {
            if (!isAnimating) return;
            const slider = document.getElementById('criticalT');
            const speed = parseFloat(document.getElementById('animSpeed').value) * 0.01;
            let t = parseFloat(slider.value) + speed;
            if (t > 1000) t = 0;
            slider.value = t;
            document.getElementById('tValue').textContent = t.toFixed(4);
            compute();
            animationId = requestAnimationFrame(animate);
        }
        
        function resetAnimation() {
            isAnimating = false;
            document.getElementById('animateBtn').textContent = 'Animate t Parameter';
            if (animationId) cancelAnimationFrame(animationId);
            document.getElementById('criticalT').value = 14.134725;
            document.getElementById('tValue').textContent = '14.1347';
            compute();
        }
        
        function clearHistory() {
            historyData = [];
            document.getElementById('historyStats').textContent = 'Data Points: 0';
            renderHistory();
        }
        
        ['modulus', 'criticalT', 'primeCutoff', 'alpha', 'beta', 'gamma', 'pathOpacity', 'gridOpacity', 'animSpeed', 'canvasZoomSlider'].forEach(id => {
            const slider = document.getElementById(id);
            const input = document.getElementById(id + 'Input');
            
            slider.addEventListener('input', function() {
                const displays = { 
                    modulus: 'mValue', criticalT: 'tValue', primeCutoff: 'xValue', 
                    alpha: 'alphaValue', beta: 'betaValue', gamma: 'gammaValue', 
                    pathOpacity: 'opacityValue', gridOpacity: 'gridOpacityValue', animSpeed: 'speedValue',
                    canvasZoomSlider: 'canvasZoomValue'
                };
                const el = document.getElementById(displays[id]);
                if (el) {
                    if (id === 'pathOpacity' || id === 'gridOpacity' || id === 'canvasZoomSlider') {
                        el.textContent = this.value + '%';
                    } else if (['alpha', 'beta', 'gamma', 'criticalT'].includes(id)) {
                        el.textContent = parseFloat(this.value).toFixed(4);
                    } else {
                        el.textContent = this.value;
                    }
                }
                
                if (input) input.value = this.value;
                
                if (id === 'canvasZoomSlider') {
                    render();
                } else if (!isAnimating) {
                    compute();
                }
            });
            
            if (input) {
                input.addEventListener('input', function() {
                    const val = parseFloat(this.value);
                    const min = parseFloat(slider.min);
                    const max = parseFloat(slider.max);
                    
                    if (!isNaN(val) && val >= min && val <= max) {
                        slider.value = val;
                        const displays = { 
                            modulus: 'mValue', criticalT: 'tValue', primeCutoff: 'xValue', 
                            alpha: 'alphaValue', beta: 'betaValue', gamma: 'gammaValue', 
                            pathOpacity: 'opacityValue', gridOpacity: 'gridOpacityValue', animSpeed: 'speedValue' 
                        };
                        const el = document.getElementById(displays[id]);
                        if (id === 'pathOpacity' || id === 'gridOpacity') el.textContent = val + '%';
                        else if (['alpha', 'beta', 'gamma', 'criticalT'].includes(id)) el.textContent = val.toFixed(4);
                        else el.textContent = val;
                        
                        if (!isAnimating) compute();
                    }
                });
            }
        });
        
        ['showPath', 'showGrid', 'showLegend', 'useGradient', 'showDensity'].forEach(id => {
            const el = document.getElementById(id);
            if (el) {
                el.addEventListener('change', () => {
                    render();
                    renderPhaseSpace();
                    renderHistory();
                });
            }
        });
        
        document.getElementById('useOEISToggle').addEventListener('change', () => {
            if (document.getElementById('useOEISToggle').checked && oeisSequence.length === 0) {
                document.getElementById('oeisStatus').textContent = 'Please load a sequence first (select from dropdown or upload).';
                document.getElementById('oeisStatus').style.color = '#ff6464';
            } else {
                compute();
            }
        });
        
        ['pathColor', 'pathEndColor', 'resultColor', 'gridColor', 'originColor'].forEach(id => {
            document.getElementById(id).addEventListener('input', () => {
                render();
                renderPhaseSpace();
                renderHistory();
            });
        });
        
        setupCanvasInteraction('mainCanvas', 'main');
        setupCanvasInteraction('phaseCanvas', 'phase');
        setupCanvasInteraction('historyCanvas', 'history');
        
        function switchTab(tabName) {
            document.querySelectorAll('.tab-content').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
            
            const tabElement = document.getElementById(tabName + 'Tab');
            if (tabElement) {
                tabElement.classList.add('active');
            }
            
            // Find and activate the corresponding button
            const buttons = document.querySelectorAll('.tab-btn');
            buttons.forEach(btn => {
                if (btn.textContent.toLowerCase().includes(tabName.toLowerCase()) ||
                    (tabName === 'visualization' && btn.textContent === 'Visualization') ||
                    (tabName === 'parametersweep' && btn.textContent === 'Parameter Sweep') ||
                    (tabName === 'gapanalysis' && btn.textContent === 'Prime Gap Analysis') ||
                    (tabName === 'sessions' && btn.textContent === 'Sessions') ||
                    (tabName === 'documentation' && btn.textContent === 'Mathematical Framework') ||
                    (tabName === 'credits' && btn.textContent === 'Credits & References')) {
                    btn.classList.add('active');
                }
            });
        }
        
        initZeros();
        compute();
        loadFromURL();
        refreshSessions();
        updateSessionInfo();
    </script>
</body>
</html>
